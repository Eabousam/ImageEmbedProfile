---
title: "CRC Image Feature Analysis"
format:
  html:
    theme: yeti
    highlight-style: tango
    toc: true
    toc-depth: 3
    toc-floating: true
---

## Image Analysis: TCGAData

#### Setting up libraries

```{r}
#| output: False
library(rmarkdown)
library(knitr)
library(psych)
library(imageFeatureTCGA)
library(curatedTCGAData)
library(SummarizedExperiment)
library(dplyr)
library(MOFA2)
library(TCGAutils)
library(ggplot2)
```

#### prov-gigaPath Cancer WSI MOFA2


# Load slide data catalog

```{r load embeddings}
catalog_coad <- getCatalog("provgigapath") |> 
    dplyr::filter(level == "slide_level", Project.ID == "TCGA-COAD") |>
     dplyr::slice(1:n())

catalog_read <- getCatalog("provgigapath") |> 
    dplyr::filter(level == "slide_level", Project.ID == "TCGA-READ") |>
   dplyr::slice(1:n())

ov_catalog <- getCatalog("provgigapath") |> 
    dplyr::filter(level == "slide_level", Project.ID == "TCGA-OV") |>
  dplyr::slice(1:n())

```

# Read Ovarian Cancer assay with curatedTCGA

```{r load_rnaseq, message=FALSE}
#------------------------------------------
# Load OV assays
#------------------------------------------

OV_mae_all <- curatedTCGAData(
  diseaseCode = "OV",
  assays = "*",
  version = "2.1.1",
  dry.run = FALSE
)

OV_assays_subset <- c(
    "OV_RNASeq2GeneNorm-20160128", # RNAseq
    "OV_Methylation_methyl450-20160128", # Methylation
    "OV_RPPAArray-20160128") # Proteomics
ov_mae <- OV_mae_all[,,which(names(OV_mae_all) %in% OV_assays_subset)]


```


# Link OV MAE data to the MultiAssayExperiment using linkTCGA

```{r linktcga}

ov_mae_emb <-
    linkTCGA(ov_mae, ov_catalog, redownload = FALSE, parallel = FALSE)

## create artificial rownames for MOFA2
rownames(ov_mae_emb[["slide_assay"]]) <-
    paste0("slide_feat_", seq_len(nrow(ov_mae_emb[["slide_assay"]])))
```

# Run MOFA

```{r run_mofa}
# Create MOFA object from MultiAssayExperiment
mofa_obj <- create_mofa_from_MultiAssayExperiment(ov_mae_emb)

# Set data options
data_opts <- get_default_data_options(mofa_obj)

# Set model options
model_opts <- get_default_model_options(mofa_obj)
model_opts$num_factors <- 15  # the default

# Set training options
train_opts <- get_default_training_options(mofa_obj)

# currently set to fast for vignette rendering speed but slow is recommended
train_opts$convergence_mode <- "fast" 

train_opts$seed <- 42

# Prepare the model
mofa_obj <- prepare_mofa(
    object = mofa_obj,
    data_options = data_opts,
    model_options = model_opts,
    training_options = train_opts
)
test_model_file <- tempfile(fileext = ".hdf5")
# Train the model
mofa_obj.trained <- run_mofa(
    mofa_obj,
    outfile = test_model_file,
    use_basilisk = TRUE
)
```

# Visualize MOFA results

```{r load and visualize the model}
mofa_object.trained <- load_model(test_model_file)

plot_variance_explained(mofa_object.trained)
```



```{r}
#| label: train-mofa-model

# Run/train the model 

mofa_object.trained <- run_mofa(
  mofa_object,
  outfile = "mofa_model_rnaseq_lastembed.hdf5",
  use_basilisk = TRUE
)

# Load trained MOFA model
mofa_object.trained <- load_model("mofa_model_rnaseq_lastembed.hdf5")

#------------------------------------------
# 1. Get MOFA sample names
#------------------------------------------
mofa_samples <- unlist(samples_names(mofa_object.trained))  # vector of sample IDs

#------------------------------------------
# 2. Subset metadata to match MOFA samples
#------------------------------------------
metadata_matched <- metadata_df[mofa_samples, , drop = FALSE]

# Ensure rownames match MOFA sample names exactly
rownames(metadata_matched) <- mofa_samples

#------------------------------------------
# 3. Add sample column if needed
#------------------------------------------
metadata_matched$sample <- rownames(metadata_matched)

#------------------------------------------
# 4. Assign metadata to MOFA object
#------------------------------------------
samples_metadata(mofa_object.trained) <- metadata_matched

# Save the updated object (RDS is easiest)
saveRDS(mofa_object.trained, file = "mofa_model_lastembed_with_metadata.rds")


# visualize the model views and samples
plot_data_overview(mofa_object.trained)

# Plot factor correlations to check for interdependence issues with the model
plot_factor_cor(mofa_object.trained)


# Plot variance explained
plot_variance_explained(mofa_object.trained)

plot_variance_explained(mofa_object.trained, plot_total = T)
print(mofa_object.trained@cache$variance_explained)


```



## misc

```{r}
# Extract embedding matrices
mat_layer0  <- assay(embedding_se_layer0, "embedding")
mat_layer10 <- assay(embedding_se_layer10, "embedding")
mat_layer11 <- assay(embedding_se_layer11, "embedding")
mat_layer12 <- assay(embedding_se_layer12, "embedding")
mat_last    <- assay(embedding_se_last, "embedding")

# Calculate correlation between same embedding dimensions across layers
layer_corr <- data.frame(
  dim = rownames(mat_layer0),
  cor_0_10  = diag(cor(t(mat_layer0), t(mat_layer10))),
  cor_10_11 = diag(cor(t(mat_layer10), t(mat_layer11))),
  cor_11_12 = diag(cor(t(mat_layer11), t(mat_layer12))),
  cor_12_last = diag(cor(t(mat_layer12), t(mat_last)))
)

head(layer_corr)
summary(layer_corr)
```


#### Load in TCGA CRC assay experiment data

```{r}
#| output: False
#| message: false

# List available Assays
curatedTCGAData("COAD", "*",version = "2.1.1", dry.run = TRUE) 
curatedTCGAData("READ", "*",version = "2.1.1", dry.run = TRUE) 


# Load COAD data with multiple assays
coad_mae_full <- curatedTCGAData(
    diseaseCode = "COAD",
    assays = c("COAD_RNASeq2GeneNorm-20160128", "mRNAArray", "miRNASeqGene"),
    version = "2.1.1",
    dry.run = FALSE
)

# Load READ data (rectal)
read_mae_full <- curatedTCGAData(
    diseaseCode = "READ",
    assays = c("READ_RNASeq2GeneNorm-20160128", "mRNAArray", "miRNASeqGene"),
    version = "2.1.1",
    dry.run = FALSE
)

```

#### Read Clinical Metadata data and subset

```{r}
#| output: False
# ---- Extract sample-level metadata for READ ----- 
read_clinical <- colData(read_mae_full)

# Check completeness of metadata attributes
completeness <- colSums(!is.na(read_clinical)) / nrow(read_clinical) * 100
summary(completeness)

# Subset to attributes with >95% completeness and remove technical fields
read_clinical_sub <- read_clinical[, which(completeness > 95)] %>%
  as.data.frame() %>%
  select(-matches("aliquot")) %>%
  select(-matches("portion"))


# ------ Extract sample-level metadata for COAD ------
coad_clinical <- colData(coad_mae_full)

# Check completeness of metadata attributes
completeness <- colSums(!is.na(coad_clinical)) / nrow(coad_clinical) * 100

coad_clinical_sub <- coad_clinical[, which(completeness > 95)] %>%
  as.data.frame() %>%
  select(-matches("aliquot")) %>%
  select(-matches("portion"))


```

#### Matching embedding with clinical metadata

```{r}
#| output: False
# Merge COAD + READ clinical metadata
all_cols <- union(colnames(coad_clinical_sub), colnames(read_clinical_sub))

coad_clinical_full <- coad_clinical_sub
for (col in setdiff(all_cols, colnames(coad_clinical_sub))) coad_clinical_full[[col]] <- NA

read_clinical_full <- read_clinical_sub
for (col in setdiff(all_cols, colnames(read_clinical_sub))) read_clinical_full[[col]] <- NA

clinical_combined <- rbind(coad_clinical_full, read_clinical_full)

# Keep only patients with embeddings
# Convert embedding matrix rownames to patient IDs (first 3 components)
patient_ids_from_embedding <- sapply(strsplit(rownames(tensor_matrix_full), "-"), 
                                    function(x) paste(x[1:3], collapse = "-"))
rownames(tensor_matrix_full) <- patient_ids_from_embedding

# Convert clinical data rownames to patient IDs (first 3 components)
clinical_patient_ids <- sapply(strsplit(rownames(clinical_combined), "-"), 
                              function(x) paste(x[1:3], collapse = "-"))
rownames(clinical_combined) <- clinical_patient_ids

# Remove duplicate patients from clinical data (keep first occurrence)
clinical_combined <- clinical_combined[!duplicated(rownames(clinical_combined)), ]

# Keep only patients with embeddings
patients_with_embed <- rownames(tensor_matrix_full)
clinical_combined <- clinical_combined[rownames(clinical_combined) %in% patients_with_embed, ]

# Factorize categorical variables with 2-10 unique values
numLv <- apply(clinical_combined, 2, function(x) length(unique(na.omit(x))))
slideAttrNames <- names(numLv[numLv >= 2 & numLv <= 10])

for(attr in slideAttrNames){
  clinical_combined[[attr]] <- as.factor(clinical_combined[[attr]])
}

# Create final metadata dataframe
metadata_embed_df <- clinical_combined[slideAttrNames]

# Remove any rows with all NA values
metadata_embed_df <- metadata_embed_df[rowSums(is.na(metadata_embed_df)) < ncol(metadata_embed_df), ]

# Subset embedding matrix to match metadata patients
embedding_embed_mat <- tensor_matrix_full[rownames(tensor_matrix_full) %in% rownames(metadata_embed_df), ]
embedding_embed_mat <- embedding_embed_mat[!duplicated(rownames(embedding_embed_mat)), ]

# Ensure exact same patients in both datasets
common_patients <- intersect(rownames(embedding_embed_mat), rownames(metadata_embed_df))
embedding_embed_mat <- embedding_embed_mat[common_patients, ]
metadata_embed_df <- metadata_embed_df[common_patients, ]

# Run HistoImageR embedding separation analysis
res_embed <- HistoImageR:::analyze_embedding_separation(embedding_embed_mat, metadata_embed_df)

# View results
res_embed$plots
```


