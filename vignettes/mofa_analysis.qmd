---
title: "Multi-Omics Factor Analysis (MOFA) & preranked Gene Enrichment (GSEA) Cancer Imaging"
format: 
  html:
    theme: yeti
    highlight-style: tango
    toc: true
    toc-depth: 3
    toc-floating: true
editor: visual
execute:
  echo: false
  warning: false
  message: false
  include: false
  results: "hide"
  fig-width: 10
  fig-height: 8
  fig-dpi: 300
editor_options: 
  chunk_output_type: inline
---


## Libraries 
```{r setup, include=FALSE}
# Load required libraries
library(MOFA2)
library(survival)
library(survminer)
library(curatedTCGAData)
library(fgsea)
library(msigdbr)  
library(enrichplot)
library(ggplot2)
library(dplyr)
library(genekitr)
library(GSVA)
library(Hmisc)
library(pheatmap)
library(DT)

devtools::load_all()

```



#### Analyze MOFA model

```{r, include =TRUE, echo = TRUE}
#| label: load-mofa
# Load trained MOFA model

mofa_object.trained <- readRDS("mofa_model_with_metadata.rds")
# visualize the model views and samples
plot_data_overview(mofa_object.trained)

# Plot factor correlations to check for interdependence issues with the model
plot_factor_cor(mofa_object.trained)


# Plot variance explained
plot_variance_explained(mofa_object.trained, plot_total = TRUE)

print(mofa_object.trained@cache$variance_explained)



```

#### Initial visualizations

```{r}
#| label: mofa-visualization
#| warning: false




# Plot data heatmaps
# using rna seq view
plot_data_heatmap(mofa_object.trained,
                   scale = "row",
                   cluster_cols = FALSE,
                   cluster_rows = FALSE,
                   show_colnames = FALSE,
                   denoise = TRUE,
                   features = 10,
                   view = "RNASeq",
                   factor=1)

# Using embedding view
plot_data_heatmap(mofa_object.trained,
                  factor = 1,
                  view = "Embedding_layer0",
                  features = 10,
                  cluster_rows = FALSE,
                  cluster_cols = FALSE,
                  show_colnames = FALSE)

# Plot top weights 
plot_top_weights(mofa_object.trained,
                 view = "RNASeq",
                 factor = 1,
                 nfeatures = 10)


# Plot factor colored by pathology stage
plot_factor(mofa_object.trained, 
            factor = 1, 
            add_violin = T,
            dodge = TRUE,
            color_by = "MYH11")

# Plot factor scatter
plot_factor(mofa_object.trained, 
            factor = c(1, 2), 
            color_by = "pathology_T_stage")

plot_top_weights(mofa_object.trained,
                 view = "Embedding_layer0",
                 factor = 1,
                 nfeatures = 10)

# Correlate factors with clinical variables
correlate_factors_with_covariates(mofa_object.trained, 
                      covariates = c("vital_status.x","pathology_M_stage","tumor_tissue_site"), 
                      plot = "log_pval" )



```



# Factor Contribution

```{r}
# ================================
# Factor Contribution Analysis
# ================================

# 1. Extract loadings (factor weights) for each view
#    MOFA provides loadings per view (e.g. RNASeq, embeddings).
loadings_rnaseq_list <- get_weights(mofa_object.trained, views = "RNASeq")
loadings_embed_list  <- get_weights(mofa_object.trained, views = "Embedding_layer0")

# 2. Convert lists of loadings into numeric matrices
#    Each column corresponds to a factor; each row to a feature (gene, embedding dim).
loadings_rnaseq <- do.call(cbind, loadings_rnaseq_list)
loadings_embed  <- do.call(cbind, loadings_embed_list)

# 3. Compute per-factor contribution
#    Take the sum of *absolute* loadings for each factor.
#    - Absolute value ensures negative/positive weights contribute equally.
#    - This gives a "total magnitude of influence" per factor.
abs_sum_rnaseq <- colSums(abs(loadings_rnaseq))    # RNASeq
abs_sum_embed  <- colSums(abs(loadings_embed))     # Embedding

# 4. Organize results into tidy format for plotting
abs_sum_df <- data.frame(
  Factor    = 1:length(abs_sum_rnaseq),   # factor index
  RNASeq    = abs_sum_rnaseq,
  Embedding = abs_sum_embed
) %>%
  pivot_longer(
    cols = c("RNASeq", "Embedding"), 
    names_to = "View", 
    values_to = "AbsSum"
  )

# 5. Plot per-factor absolute contributions
#    Shows how much each factor is "used" within each view.
ggplot(abs_sum_df, aes(x = Factor, y = AbsSum, fill = View)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = c("RNASeq" = "blue", "Embedding" = "orange")) +
  labs(
    title = "Sum of Absolute Loadings per Factor",
    x = "Factor",
    y = "Sum of Absolute Loadings"
  ) +
  theme_minimal()

# 6. Compute cumulative contribution across factors
#    Cumulative sum shows how much variance/information is captured
#    as more factors are included in order (Factor1 → Factor15).
cum_sum_rnaseq <- cumsum(abs_sum_rnaseq)
cum_sum_embed  <- cumsum(abs_sum_embed)

# 7. Organize cumulative results into tidy format
cum_sum_df <- data.frame(
  Factor    = 1:length(cum_sum_rnaseq),
  RNASeq    = cum_sum_rnaseq,
  Embedding = cum_sum_embed
) %>%
  pivot_longer(
    cols = c("RNASeq", "Embedding"), 
    names_to = "View", 
    values_to = "Cumsum"
  )

# 8. Plot cumulative contribution
#    Line plot shows the growth of total contribution as factors accumulate.
ggplot(cum_sum_df, aes(x = Factor, y = Cumsum, color = View)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  labs(
    title = "Cumulative Sum of Absolute Loadings Across Factors",
    x = "Factor",
    y = "Cumulative Sum of Absolute Loadings"
  ) +
  theme_minimal()
```


```{r}
plot_weights(mofa_object.trained, 
             view = 2, 
             factor = 3, 
             nfeatures = 10)
# if we have tile embeddings with some coords, we can figure out where they are in the slide image??
```


# PCA interpretation

### Matrices

```{r}
# Load helper utils fns
devtools::load_all()
dir <- "../TCGA_COAD_READ_provgigapath"
fnames <- list.files(dir, pattern = "\\.csv$", full.names = TRUE)
# Creating matrix for all the images
tensor_matrix <- matrix(nrow = length(fnames), ncol = 768)
slide_ids <- sapply(strsplit(basename(fnames), "\\.csv"), `[`, 1)
rownames(tensor_matrix) <- slide_ids

for (i in seq_along(fnames)) {
  tensor_matrix[i,] <- getEmbeddingLayer(fnames[i])
}

tensor_matrix_full <- na.omit(tensor_matrix)


#------------------------------------------
# 1. Load COAD + READ RNASeq assays
#------------------------------------------
# Load COAD
coad_mae <- curatedTCGAData(
  diseaseCode = "COAD",
  assays = "RNASeq2GeneNorm",
  version = "2.1.1",
  dry.run = FALSE
)

# Load READ
read_mae <- curatedTCGAData(
  diseaseCode = "READ",
  assays = "RNASeq2GeneNorm",
  version = "2.1.1",
  dry.run = FALSE
)

rna_coad <- coad_mae[["COAD_RNASeq2GeneNorm-20160128"]]
rna_read <- read_mae[["READ_RNASeq2GeneNorm-20160128"]]

colData(coad_mae)

#### Find common genes
#------------------------------------------
# 2. Ensure consistent genes
#------------------------------------------
common_genes <- intersect(rownames(rna_coad), rownames(rna_read))
rna_coad_bulk <- rna_coad[common_genes, ]
rna_read_bulk <- rna_read[common_genes, ]

# Merge RNASeq matrices
rna_combined <- cbind(rna_coad_bulk, rna_read_bulk)

# Standardize patient IDs (first 3 TCGA fields)
rna_patients <- sapply(strsplit(colnames(rna_combined), "-"), function(x) paste(x[1:3], collapse = "-"))
colnames(rna_combined) <- make.unique(rna_patients)

#------------------------------------------
# 3. Prepare embedding matrix
#------------------------------------------
tensor_matrix_unique <- tensor_matrix_full[!duplicated(rownames(tensor_matrix_full)), ]
embedding_patients <- sapply(strsplit(rownames(tensor_matrix_unique), "-"), function(x) paste(x[1:3], collapse = "-"))
rownames(tensor_matrix_unique) <- make.unique(embedding_patients)

#------------------------------------------
# 4. Prepare clinical metadata while keeping survival vars
#------------------------------------------

# Subset COAD clinical metadata
coad_clinical <- colData(coad_mae) %>% as.data.frame()
read_clinical <- colData(read_mae) %>% as.data.frame()

# Define survival variables to keep regardless of completeness
surv_vars <- c("vital_status.x", "days_to_death.x", 
               "patient.days_to_last_followup", "patient.days_to_last_known_alive")

# Calculate completeness for all columns
coad_completeness <- colSums(!is.na(coad_clinical)) / nrow(coad_clinical) * 100
read_completeness <- colSums(!is.na(read_clinical)) / nrow(read_clinical) * 100

# Keep columns >95% complete OR survival variables
coad_clinical_sub <- coad_clinical[, coad_completeness > 95 | colnames(coad_clinical) %in% surv_vars]
read_clinical_sub <- read_clinical[, read_completeness > 95 | colnames(read_clinical) %in% surv_vars]

# Remove aliquot/portion columns
coad_clinical_sub <- coad_clinical_sub %>% select(-matches("aliquot"), -matches("portion"))
read_clinical_sub <- read_clinical_sub %>% select(-matches("aliquot"), -matches("portion"))

# Ensure all columns exist in both datasets
all_cols <- union(colnames(coad_clinical_sub), colnames(read_clinical_sub))
for (col in setdiff(all_cols, colnames(coad_clinical_sub))) coad_clinical_sub[[col]] <- NA
for (col in setdiff(all_cols, colnames(read_clinical_sub))) read_clinical_sub[[col]] <- NA

# Merge COAD + READ metadata
clinical_sub <- rbind(coad_clinical_sub, read_clinical_sub)

# Keep only patients with embeddings
patients_with_embed <- rownames(tensor_matrix_unique)
clinical_sub <- clinical_sub[rownames(clinical_sub) %in% patients_with_embed, ]

# Factorize categorical variables with 2–10 levels, excluding survival vars
cat_vars <- setdiff(names(clinical_sub), surv_vars)
numLv <- sapply(clinical_sub[, cat_vars, drop = FALSE], function(x) length(unique(x)))
slideAttrNames <- names(numLv[numLv >= 2 & numLv <= 10])
for (slideAttrName in slideAttrNames) {
  clinical_sub[[slideAttrName]] <- as.factor(clinical_sub[[slideAttrName]])
}

# Combine factorized categorical variables with survival vars
metadata_df <- clinical_sub[, c(slideAttrNames, surv_vars)]

#------------------------------------------
# 5. Subset RNASeq to patients with embeddings
#------------------------------------------
rna_matched <- rna_combined[, colnames(rna_combined) %in% patients_with_embed, drop = FALSE]

# Remove genes with Inf/-Inf
rna_matrix <- assay(rna_matched)
rna_keep <- apply(rna_matrix, 1, function(x) all(is.finite(x)))
rna_matched_clean <- rna_matched[rna_keep, ]

# Subset embedding to match RNA columns
embedding_matched_clean <- tensor_matrix_unique[colnames(rna_matched_clean), , drop = FALSE]
as.data.frame(embedding_matched_clean)
```

```{r}
# =========================================================
# RNASeq → PCA → Correlation with Embeddings & MOFA Factors
# =========================================================

# --- Step 0: Setup matrices ---
# Ensure matrices are samples × features/dimensions
rnaseq_mat <- t(rna_matrix)              # 606 samples × 11135 genes
embedding_mat <- embedding_matched_clean # 606 samples × 266 embeddings
factors_mat <- get_factors(mofa_object.trained)[[1]] # 606 samples × 15 MOFA factors

# --- Step 1: Handle missing data in RNASeq ---
# Critical: PCA cannot handle NA values, RNASeq often has missing values
# Option: simple column mean imputation (fast) or KNN imputation (better preserves correlations)
library(matrixStats)

col_means <- colMeans(rnaseq_mat, na.rm = TRUE)
rnaseq_mat_imputed <- rnaseq_mat
for (j in seq_len(ncol(rnaseq_mat_imputed))) {
  rnaseq_mat_imputed[is.na(rnaseq_mat_imputed[, j]), j] <- col_means[j]
}

# --- Step 2: PCA on RNASeq ---
# Centering and scaling genes is standard
pca_rna <- prcomp(rnaseq_mat_imputed, center = TRUE, scale. = TRUE)
# RNA PCs (rows = samples, cols = PCs)
rna_pcs <- pca_rna$x
rownames(rna_pcs) <- rownames(rnaseq_mat)  # samples
colnames(rna_pcs) <- paste0("PC", 1:ncol(rna_pcs))

# Embeddings (rows = samples, cols = embeddings)
embedding_mat <- embedding_matched_clean
rownames(embedding_mat) <- rownames(rnaseq_mat)  # samples
colnames(embedding_mat) <- paste0("Embed", 1:ncol(embedding_mat))
# --- Step 3: Correlation of RNASeq PCs with MOFA factors ---
# Check how RNASeq variation aligns with MOFA latent factors
cor_pc_factors <- cor(rna_pcs, factors_mat) # PCs × Factors

# --- Step 4: Correlation of RNASeq PCs with embeddings ---
# Check which embeddings capture major RNASeq variation
cor_pc_embed <- cor(rna_pcs, embedding_mat) # PCs × Embeddings

# --- Step 5: Identify top correlated embeddings for each PC ---
top_n <- 5
top_embeddings <- apply(cor_pc_embed, 1, function(x) {
  # Take absolute correlation to capture strength, ignoring direction
  names(sort(abs(x), decreasing = TRUE))[1:top_n]
})


# 5. Optional: Top correlated MOFA factors for each PC
top_factors <- apply(cor_pc_factors, 1, function(x) {
  names(sort(abs(x), decreasing = TRUE))[1:top_n]
})


# cor_pc_embed is PCs × embeddings
pheatmap(cor_pc_embed,
         cluster_rows = TRUE,    # cluster PCs
         cluster_cols = TRUE,    # cluster embeddings
         show_rownames = TRUE,
         show_colnames = FALSE,  # optional if many embeddings
         color = colorRampPalette(c("blue", "white", "red"))(50),
         main = "Correlation of RNASeq PCs with Embeddings")


library(ggplot2)

# Example: top embedding for PC1
top_embed_pc1 <- names(sort(abs(cor_pc_embed[1, ]), decreasing = TRUE))[1]

df_plot <- data.frame(
  PC1 = rna_pcs[,1],
  Embedding = embedding_mat[, top_embed_pc1]
)

ggplot(df_plot, aes(x = PC1, y = Embedding)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", col = "red") +
  labs(title = paste("PC1 vs", top_embed_pc1),
       x = "RNASeq PC1", y = "Embedding") +
  theme_minimal()
```




```{r}
library(tidyverse)

# =========================================================
# DEBUG THE MAPPING ISSUE
# =========================================================

cat("=== DEBUGGING MAPPING ISSUE ===\n")

# Check the original embedding_weights structure
cat("Original embedding_weights feature column:\n")
print(head(embedding_weights$feature))
cat("Class:", class(embedding_weights$feature), "\n")
cat("Levels (first 10):", head(levels(embedding_weights$feature), 10), "\n")
cat("Levels (last 10):", tail(levels(embedding_weights$feature), 10), "\n")

# Let's see what happens when we convert to numeric
test_conversion <- as.numeric(embedding_weights$feature[1:10])
cat("Numeric conversion of first 10 features:\n")
print(test_conversion)

# Check if there are any NA values in the conversion
cat("NA values in numeric conversion:", sum(is.na(test_conversion)), "\n")

# =========================================================
# FIXED MAPPING APPROACH
# =========================================================

# The issue is that the factor levels include both genes and embeddings
# We need to extract only the embedding indices

# Method 1: Extract embedding numbers from factor levels
cat("\n=== METHOD 1: EXTRACT FROM FACTOR LEVELS ===\n")

# Get the last 768 levels (which should be the embeddings)
all_levels <- levels(embedding_weights$feature)
embedding_levels <- tail(all_levels, 768)
cat("First 5 embedding levels:", head(embedding_levels, 5), "\n")
cat("Last 5 embedding levels:", tail(embedding_levels, 5), "\n")

# Create mapping from these levels
embedding_mapping <- data.frame(
  factor_level = embedding_levels,
  embedding_name = paste0("embed_", 1:768)
)

# Apply the mapping
embedding_weights_fixed <- embedding_weights %>%
  mutate(
    feature = embedding_mapping$embedding_name[match(as.character(feature), embedding_mapping$factor_level)]
  )

# Check the result
cat("After mapping - first few features:\n")
print(head(embedding_weights_fixed$feature))
cat("NA values after mapping:", sum(is.na(embedding_weights_fixed$feature)), "\n")

# =========================================================
# METHOD 2: DIRECT STRING EXTRACTION
# =========================================================

cat("\n=== METHOD 2: DIRECT STRING EXTRACTION ===\n")

# Convert to character and check what we have
feature_chars <- as.character(embedding_weights$feature)
cat("First 10 features as character:\n")
print(head(feature_chars, 10))
cat("Last 10 features as character:\n")
print(tail(feature_chars, 10))

# Check if they contain "embed_" pattern
contains_embed <- grepl("embed_", feature_chars)
cat("Features containing 'embed_':", sum(contains_embed), "\n")

# Since they don't contain "embed_", let's assume they're all embeddings
# and map them directly
embedding_weights_fixed_v2 <- embedding_weights %>%
  mutate(
    # Convert factor to character
    feature_char = as.character(feature),
    # Extract the numeric part - they seem to be consecutive numbers
    # We'll map the smallest number to embed_1, etc.
    numeric_index = as.numeric(feature_char),
    # Find the minimum to establish offset
    min_index = min(numeric_index),
    max_index = max(numeric_index),
    # Calculate embedding number
    embed_number = numeric_index - min_index + 1,
    # Create embedding name
    feature = paste0("embed_", embed_number)
  )

cat("Range of numeric indices:", 
    min(embedding_weights_fixed_v2$numeric_index), "to", 
    max(embedding_weights_fixed_v2$numeric_index), "\n")
cat("First 5 mapped features:\n")
print(head(embedding_weights_fixed_v2$feature, 5))

# =========================================================
# SIMPLIFIED ANALYSIS WITH DIRECT MAPPING
# =========================================================

# Let's use the working mapping from Method 2
embedding_weights_clean <- embedding_weights_fixed_v2

# Simple analysis function
analyze_factor_simple <- function(factor_name) {
  cat("\nAnalyzing", factor_name, "...\n")
  
  # Get top embedding for this factor
  top_embed <- embedding_weights_clean %>%
    filter(factor == factor_name) %>%
    arrange(desc(abs(value))) %>%
    slice(1)
  
  if (nrow(top_embed) == 0) {
    cat("No embeddings found for", factor_name, "\n")
    return(NULL)
  }
  
  top_embed_name <- top_embed$feature[1]
  cat("Top embedding:", top_embed_name, "\n")
  
  # Verify the embedding exists
  if (!top_embed_name %in% colnames(embedding_matched_clean)) {
    cat("ERROR: Embedding", top_embed_name, "not found!\n")
    return(NULL)
  }
  
  # Create plot data
  plot_data <- data.frame(
    factor_score = factor_scores[, factor_name],
    embedding_value = embedding_matched_clean[, top_embed_name]
  )
  
  # Create plot
  p <- ggplot(plot_data, aes(x = factor_score, y = embedding_value)) +
    geom_point(alpha = 0.6) +
    geom_smooth(method = "lm", color = "red") +
    labs(
      title = paste(factor_name, "vs", top_embed_name),
      x = paste(factor_name, "Score"),
      y = "Embedding Value"
    ) +
    theme_minimal()
  
  # Calculate correlation
  cor_result <- cor.test(plot_data$factor_score, plot_data$embedding_value)
  
  return(list(
    factor = factor_name,
    top_embedding = top_embed_name,
    plot = p,
    correlation = cor_result$estimate,
    p_value = cor_result$p.value
  ))
}

# =========================================================
# TEST WITH FACTOR 1
# =========================================================

cat("\n=== TESTING FACTOR 1 ===\n")
factor1_result <- analyze_factor_simple("Factor1")

if (!is.null(factor1_result)) {
  print(factor1_result$plot)
  cat("Correlation:", round(factor1_result$correlation, 3), 
      "(p =", format.pval(factor1_result$p_value, digits = 3), ")\n")
} else {
  cat("Failed to analyze Factor1\n")
}

# =========================================================
# ANALYZE ALL FACTORS
# =========================================================

cat("\n=== ANALYZING ALL FACTORS ===\n")

all_factors <- paste0("Factor", 1:15)
results <- list()

for (factor in all_factors) {
  result <- analyze_factor_simple(factor)
  if (!is.null(result)) {
    results[[factor]] <- result
  }
}

# Create summary
if (length(results) > 0) {
  factor_summary <- map_dfr(results, function(res) {
    tibble(
      factor = res$factor,
      top_embedding = res$top_embedding,
      correlation = round(res$correlation, 3),
      p_value = format.pval(res$p_value, digits = 3)
    )
  })
  
  print("=== FACTOR SUMMARY ===")
  print(factor_summary)
  
  # Plot correlations
  ggplot(factor_summary, aes(x = factor, y = correlation, fill = correlation)) +
    geom_col() +
    scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
    labs(title = "MOFA Factors vs Top Embeddings Correlation",
         x = "Factor", y = "Correlation") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
} else {
  cat("No factors could be analyzed\n")
}

# =========================================================
# ALTERNATIVE: DIRECT INDEX APPROACH
# =========================================================

cat("\n=== ALTERNATIVE: DIRECT INDEX APPROACH ===\n")

# If the above still doesn't work, let's try a completely different approach
# Let's manually find the top embedding by index and map it

# Get the original numeric index for Factor1's top embedding
factor1_top_original <- embedding_weights %>%
  filter(factor == "Factor1") %>%
  arrange(desc(abs(value))) %>%
  slice(1) %>%
  pull(feature)

cat("Original top embedding for Factor1:", as.character(factor1_top_original), "\n")

# Since we know we have 768 embeddings numbered embed_1 to embed_768
# Let's just test them all to find which one has the highest correlation with Factor1
cat("\n=== BRUTE FORCE CORRELATION SEARCH ===\n")

# Calculate correlation between Factor1 and all embeddings
factor1_correlations <- sapply(1:768, function(i) {
  embed_name <- paste0("embed_", i)
  if (embed_name %in% colnames(embedding_matched_clean)) {
    cor(factor_scores[, "Factor1"], embedding_matched_clean[, embed_name])
  } else {
    NA
  }
})

# Find the embedding with highest absolute correlation
max_corr_index <- which.max(abs(factor1_correlations))
max_corr_embed <- paste0("embed_", max_corr_index)
max_corr_value <- factor1_correlations[max_corr_index]

cat("Embedding with highest correlation to Factor1:", max_corr_embed, "\n")
cat("Correlation value:", round(max_corr_value, 3), "\n")

# Plot this correlation
plot_data <- data.frame(
  factor_score = factor_scores[, "Factor1"],
  embedding_value = embedding_matched_clean[, max_corr_embed]
)

ggplot(plot_data, aes(x = factor_score, y = embedding_value)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "red") +
  labs(
    title = paste("Factor1 vs", max_corr_embed, "(Highest Correlation)"),
    x = "Factor1 Score",
    y = "Embedding Value"
  ) +
  theme_minimal()

# =========================================================
# FINAL WORKING SOLUTION
# =========================================================

# Since the MOFA weight mapping is problematic, let's use the correlation approach
# This is actually more scientifically sound anyway

cat("\n=== FINAL WORKING SOLUTION: CORRELATION-BASED ===\n")

# Function to find best embedding for each factor via correlation
find_best_embedding_for_factor <- function(factor_name) {
  correlations <- sapply(1:768, function(i) {
    embed_name <- paste0("embed_", i)
    cor(factor_scores[, factor_name], embedding_matched_clean[, embed_name])
  })
  
  best_index <- which.max(abs(correlations))
  best_embed <- paste0("embed_", best_index)
  best_corr <- correlations[best_index]
  
  return(list(
    factor = factor_name,
    best_embedding = best_embed,
    correlation = best_corr
  ))
}

# Analyze all factors
final_results <- map(all_factors, find_best_embedding_for_factor)

# Create final summary
final_summary <- map_dfr(final_results, function(res) {
  # Get top RNA genes for this factor
  top_rna <- rna_weights %>%
    filter(factor == res$factor) %>%
    arrange(desc(abs(value))) %>%
    head(5) %>%
    pull(feature) %>%
    paste(collapse = ", ")
  
  tibble(
    factor = res$factor,
    best_embedding = res$best_embedding,
    correlation = round(res$correlation, 3),
    top_rna_genes = top_rna
  )
})

print("=== FINAL SUMMARY (CORRELATION-BASED) ===")
print(final_summary)


```


# Visualize Correlations

```{r}

# Plot all correlations
ggplot(final_summary, aes(x = factor, y = correlation, fill = correlation)) +
  geom_col() +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
  labs(title = "MOFA Factors vs Best-Correlated Embeddings",
       x = "Factor", y = "Correlation") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))



library(ggplot2)
library(dplyr)
library(tidyr)
library(ggrepel)

# =========================================================
# ENHANCED PLOT WITH COMPLETE INFORMATION
# =========================================================

# First, let's create a more comprehensive summary that includes biological pathways
enhanced_summary <- final_summary %>%
  # Add pathway information from GSEA results
  left_join(
    map_dfr(all_factors, function(factor_name) {
      # Get GSEA results for this factor
      factor_ranks <- rna_weights %>%
        filter(factor == factor_name) %>%
        select(feature, value) %>%
        deframe()
      factor_ranks <- sort(factor_ranks, decreasing = TRUE)
      
      # Run GSEA on hallmark pathways
      gsea_res <- fgsea(pathways_hallmark, factor_ranks, 
                       minSize = 15, maxSize = 500)
      
      # Get top positive and negative pathways
      top_pos <- gsea_res %>% 
        filter(NES > 0) %>% 
        arrange(pval) %>% 
        slice(1)
      top_neg <- gsea_res %>% 
        filter(NES < 0) %>% 
        arrange(pval) %>% 
        slice(1)
      
      tibble(
        factor = factor_name,
        top_positive_pathway = ifelse(nrow(top_pos) > 0, top_pos$pathway, NA),
        top_negative_pathway = ifelse(nrow(top_neg) > 0, top_neg$pathway, NA),
        top_pathway_pval = ifelse(nrow(top_pos) > 0, top_pos$pval, NA)
      )
    }),
    by = "factor"
  ) %>%
  # Create cleaner pathway names (remove HALLMARK_ prefix)
  mutate(
    top_positive_pathway_clean = gsub("HALLMARK_", "", top_positive_pathway),
    top_negative_pathway_clean = gsub("HALLMARK_", "", top_negative_pathway),
    # Create a combined biological interpretation
    biological_interpretation = case_when(
      !is.na(top_positive_pathway) & !is.na(top_negative_pathway) ~ 
        paste0("Pos: ", top_positive_pathway_clean, "\nNeg: ", top_negative_pathway_clean),
      !is.na(top_positive_pathway) ~ paste0("Pos: ", top_positive_pathway_clean),
      !is.na(top_negative_pathway) ~ paste0("Neg: ", top_negative_pathway_clean),
      TRUE ~ "No significant pathways"
    )
  )

# =========================================================
# PLOT 1: DETAILED CORRELATION BAR PLOT
# =========================================================

p1 <- ggplot(enhanced_summary, 
             aes(x = reorder(factor, correlation), 
                 y = correlation, 
                 fill = correlation)) +
  geom_col(width = 0.7) +
  # Add correlation value labels
  geom_text(aes(label = sprintf("%.3f", correlation), 
                y = ifelse(correlation > 0, correlation + 0.05, correlation - 0.05)),
            size = 3, fontface = "bold") +
  # Add embedding labels
  geom_text(aes(label = best_embedding, 
                y = ifelse(correlation > 0, -0.15, 0.15)),
            size = 2.8, color = "darkblue", fontface = "italic") +
  scale_fill_gradient2(
    low = "blue", 
    mid = "white", 
    high = "red", 
    midpoint = 0,
    name = "Correlation\nStrength"
  ) +
  labs(
    title = "MOFA Factors vs Best-Correlated Image Embeddings",
    subtitle = "Top: Correlation values | Bottom: Embedding dimension names",
    x = "MOFA Factors (ordered by correlation strength)",
    y = "Correlation Coefficient",
    caption = paste("Analysis includes", nrow(enhanced_summary), 
                   "factors with their best-matching embedding dimensions")
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 9),
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 10, color = "gray50"),
    legend.position = "right",
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank()
  ) +
  # Ensure we have enough space for labels
  scale_y_continuous(expand = expansion(mult = c(0.2, 0.2)))

print(p1)

# =========================================================
# PLOT 2: BUBBLE PLOT WITH BIOLOGICAL CONTEXT
# =========================================================

# Create a more comprehensive visualization
p2 <- ggplot(enhanced_summary, 
             aes(x = reorder(factor, correlation), 
                 y = correlation)) +
  # Points sized by absolute correlation
  geom_point(aes(size = abs(correlation), 
                 color = correlation,
                 fill = correlation), 
             shape = 21, stroke = 1.5) +
  # Add embedding labels with repulsion
  geom_text_repel(
    aes(label = best_embedding),
    size = 3,
    box.padding = 0.5,
    segment.color = "gray50",
    min.segment.length = 0
  ) +
  # Add correlation values
  geom_text(
    aes(label = sprintf("%.3f", correlation),
        y = ifelse(correlation > 0, correlation + 0.08, correlation - 0.08)),
    size = 2.5,
    fontface = "bold"
  ) +
  scale_size_continuous(
    range = c(3, 10),
    name = "|Correlation|"
  ) +
  scale_color_gradient2(
    low = "blue", 
    mid = "gray", 
    high = "red", 
    midpoint = 0,
    name = "Correlation\nDirection"
  ) +
  scale_fill_gradient2(
    low = "blue", 
    mid = "white", 
    high = "red", 
    midpoint = 0,
    name = "Correlation\nDirection"
  ) +
  labs(
    title = "Multi-Modal Integration: MOFA Factors vs Image Embeddings",
    subtitle = "Bubble size = Correlation strength | Color = Direction",
    x = "MOFA Factors",
    y = "Correlation Coefficient",
    caption = "Labels show the specific embedding dimension with highest correlation"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
    axis.text.y = element_text(size = 9),
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 10, color = "gray50"),
    legend.position = "right",
    panel.grid.major = element_line(color = "gray90")
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50")

print(p2)

# =========================================================
# PLOT 3: FACETED PLOT WITH BIOLOGICAL PATHWAYS
# =========================================================

# Create a long format for faceting
facet_data <- enhanced_summary %>%
  select(factor, correlation, best_embedding, 
         top_positive_pathway_clean, top_negative_pathway_clean,
         top_rna_genes) %>%
  mutate(
    # Shorten RNA genes for display
    top_rna_genes_short = sapply(strsplit(top_rna_genes, ", "), function(x) {
      paste(head(x, 3), collapse = ", ")
    }),
    # Create factor label with embedding
    factor_label = paste0(factor, "\n(", best_embedding, ")")
  )

p3 <- ggplot(facet_data, aes(x = 1, y = correlation, fill = correlation)) +
  geom_col() +
  geom_text(aes(label = sprintf("r = %.3f", correlation)), 
            vjust = ifelse(facet_data$correlation > 0, -0.5, 1.2),
            size = 3, fontface = "bold") +
  facet_wrap(~ reorder(factor_label, correlation), ncol = 5) +
  scale_fill_gradient2(
    low = "blue", mid = "white", high = "red", midpoint = 0,
    guide = "none"  # Remove legend for cleaner look
  ) +
  labs(
    title = "Detailed View: MOFA Factor Correlations with Biological Context",
    subtitle = "Each panel shows one MOFA factor and its best-correlated embedding",
    x = NULL,
    y = "Correlation Coefficient"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.text = element_text(face = "bold", size = 9),
    panel.spacing = unit(1, "lines"),
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 10, color = "gray50")
  ) +
  # Add biological context as annotations
  geom_text(
    data = facet_data,
    aes(x = 1, y = ifelse(correlation > 0, -0.3, 0.3),
        label = top_positive_pathway_clean),
    size = 2.2, color = "darkgreen", fontface = "italic"
  )

print(p3)

# =========================================================
# PLOT 4: HEATMAP-STYLE VISUALIZATION
# =========================================================

# Create a matrix for heatmap
correlation_matrix <- final_summary %>%
  select(factor, best_embedding, correlation) %>%
  mutate(
    embedding_num = as.numeric(gsub("embed_", "", best_embedding))
  ) %>%
  arrange(embedding_num)

p4 <- ggplot(correlation_matrix, 
             aes(x = factor, y = best_embedding, fill = correlation)) +
  geom_tile(color = "white", size = 0.5) +
  geom_text(aes(label = sprintf("%.3f", correlation)), 
            color = "white", size = 3, fontface = "bold") +
  scale_fill_gradient2(
    low = "blue", mid = "white", high = "red", midpoint = 0,
    name = "Correlation"
  ) +
  labs(
    title = "Heatmap: MOFA Factor - Embedding Correlations",
    subtitle = "Each cell shows correlation between a factor and its best-matching embedding",
    x = "MOFA Factors",
    y = "Best-Matching Embedding Dimensions"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
    axis.text.y = element_text(size = 8),
    plot.title = element_text(face = "bold", size = 14),
    panel.grid = element_blank()
  )

print(p4)


# =========================================================
# INTERACTIVE PLOT (if you have plotly)
# =========================================================

# Uncomment if you want interactive plots
# library(plotly)
# 
# interactive_plot <- ggplot(enhanced_summary,
#                           aes(x = reorder(factor, correlation), 
#                               y = correlation,
#                               text = paste("Factor:", factor,
#                                           "<br>Embedding:", best_embedding,
#                                           "<br>Correlation:", round(correlation, 3),
#                                           "<br>Top Pathway:", top_positive_pathway_clean,
#                                           "<br>Top Genes:", top_rna_genes))) +
#   geom_col(aes(fill = correlation)) +
#   scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
#   labs(title = "Interactive: MOFA Factors vs Embeddings",
#        x = "Factor", y = "Correlation") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
# 
# ggplotly(interactive_plot, tooltip = "text")

# =========================================================
# PRINT KEY INSIGHTS
# =========================================================

cat("\n=== KEY INSIGHTS ===\n")
cat("Strongest positive correlation:", 
    enhanced_summary$factor[which.max(enhanced_summary$correlation)], 
    "with", enhanced_summary$best_embedding[which.max(enhanced_summary$correlation)],
    "(r =", round(max(enhanced_summary$correlation), 3), ")\n")

cat("Strongest negative correlation:", 
    enhanced_summary$factor[which.min(enhanced_summary$correlation)], 
    "with", enhanced_summary$best_embedding[which.min(enhanced_summary$correlation)],
    "(r =", round(min(enhanced_summary$correlation), 3), ")\n")

cat("Most frequently associated embedding:",
    names(which.max(table(enhanced_summary$best_embedding))), "\n")

cat("Average absolute correlation:",
    round(mean(abs(enhanced_summary$correlation)), 3), "\n")
```

```{r}

# =========================================================
# Embedding correlations with factors + gsea interpretations
# =========================================================

cat("\n=== COMPREHENSIVE FACTOR-EMBEDDING SUMMARY ===\n")

embedding_corr_table <- enhanced_summary %>%
  select(
    Factor = factor,
    `Best Embedding` = best_embedding,
    Correlation = correlation,
    `Top Positive Pathway` = top_positive_pathway_clean,
    `Top Negative Pathway` = top_negative_pathway_clean,
    `Top RNA Genes` = top_rna_genes
  ) %>%
  arrange(desc(abs(Correlation)))

print(embedding_corr_table)

# Save as CSV for further analysis
write.csv(comprehensive_table, "mofa_factor_embedding_analysis.csv", row.names = FALSE)
```




# Gene set Analysis


	•	GSEA (Subramanian et al., 2005) > standard for testing global enrichment. (FGSEA fast preranked gene set enrichment analysis)
	•	GSVA (Hänzelmann et al., 2013) > extends this by providing sample-wise enrichment scores, enabling downstream associations with phenotypes or latent factors.


## Gene sets

```{r, GSEA, include=TRUE, echo=TRUE}

# get Hallmark gene sets
#50 curated gene sets representing broad, well-defined biological processes (e.g., MYC targets, E2F targets, KRAS signaling, apoptosis)
pathways_hallmark <- msigdbr(species = "Homo sapiens", collection = "H") %>%
  split(x = .$gene_symbol, f = .$gs_name)

# get c2 gene sets
# Gene sets representing signatures of oncogene activation or inactivation (e.g., KRAS, MYC, E2F, PTEN loss).
pathways_c6 <- msigdbr(species = "Homo sapiens", collection = "C6") %>%
  split(x = .$gene_symbol, f = .$gs_name)

# get c2 gene sets
#Pathway databases and expert-curated gene sets, subdivided into:
##CGP (chemical/genetic perturbations) → genes responsive to drugs or perturbations.
##CP (canonical pathways) → pathways from KEGG, Reactome, BioCarta.
pathways_c2 <- msigdbr(species = "Homo sapiens", collection = "C2") %>%
  split(x = .$gene_symbol, f = .$gs_name)




```



## Run FGSEA
```{r}

## Run FGSEA for all factors

#gene set enrichment analysis (GSEA) to identify biological pathways and programs associated with the latent factors
# Extract weights for Factor 1 in RNASeq
# we extracted the feature weights for the top contributing genes in the rnaseq view, which represent the genes most associated with factor 1

all_weights <- get_weights(mofa_object.trained, 
                           views = "RNASeq", 
                           factors = "all", 
                           as.data.frame = TRUE)

# For each factor, run GSEA to understand biological meaning
factor_interpretation <- list()

for(factor_id in unique(all_weights$factor)) {
  # factor_id already has the form "Factor1", "Factor2", etc.
  
  # Get weights for this factor
  factor_weights <- all_weights[all_weights$factor == factor_id, ]
  
  # Create ranked list
  ranks <- factor_weights$value
  names(ranks) <- factor_weights$feature
  ranks <- sort(ranks, decreasing = TRUE)
  
  # Run GSEA on multiple gene set collections
  hallmark_res <- fgsea(pathways_hallmark, ranks, minSize = 15, maxSize = 500)
  c2_res      <- fgsea(pathways_c2, ranks, minSize = 15, maxSize = 500)
  c6_res      <- fgsea(pathways_c6, ranks, minSize = 15, maxSize = 500)
  
  # Store top pathways for interpretation
  factor_interpretation[[factor_id]] <- list(
    hallmark_top = hallmark_res[order(hallmark_res$pval), ][1:20, ],
    c2_top       = c2_res[order(c2_res$pval), ][1:20, ],
    c6_top       = c6_res[order(c6_res$pval), ][1:20, ]
  )
}


# Check any of the gene sets with factors
factor_interpretation$Factor1$hallmark_top

```

**Explanation of GSEA output (fgsea):**

- **pathway** – Name of the gene set tested (e.g., Hallmark pathways).  
- **pval** – Raw p-value from the enrichment test.  
- **padj** – Adjusted p-value (FDR corrected).  
- **ES (Enrichment Score)** – Degree to which a gene set is overrepresented at the top or bottom of the ranked list.  
- **NES (Normalized Enrichment Score)** – Enrichment score normalized for gene set size, used to compare across gene sets.  
- **size** – Number of genes in the pathway that overlap with the ranked list.  
- **leadingEdge** – Subset of genes that contribute most to the enrichment signal. 


- Hallmark pathways from the GSEA results, ranked by normalized enrichment score (NES), with bars colored by whether the adjusted p-value (FDR) is significant (< 0.05).

- MYC targets (V1, V2), E2F targets, and KRAS signaling are strongly negatively enriched, suggesting suppression of cell-cycle–related and oncogenic signaling programs in the context of the factors identified by MOFA. 
  * MYC is a master regulator of proliferation, metabolism, and growth (Dang, Cell, 2012).


- epithelial–mesenchymal transition (EMT), inflammatory response, interferon gamma response, and allograft rejection. This points to activation of immune and stromal programs.






## Factor Enrichment plot

```{r, include=TRUE}
# Plot enrichment for Factor1, top Hallmark pathway
enrichment_plot <- plot_factor_enrichment("Factor1", pathway_collection = "hallmark", top_n = 3, all_weights = all_weights)

# Display the plot
if(!is.null(enrichment_plot)) {
  print(enrichment_plot[[1]])
}
```

* GSEA identified HALLMARK_MYC_TARGETS_V1 as one of the most significantly enriched pathways (FDR q < 1e-28), indicating a central role of MYC-driven transcriptional programs in our dataset. Complementarily, GSVA revealed that MYC target activity varies across samples and is negatively correlated with MOFA Factor 1, suggesting that MYC activation is antagonistic to the biological processes captured by this factor. 



## Run GSVA
```{r}
# Extract RNA-seq expression from MOFA
rna_se <- get_data(mofa_object.trained, view = "RNASeq")[[1]]  # first group if multiple
expr_mat <- as.matrix(rna_se$group1)  # genes x samples
# Hallmark
param_hallmark <- ssgseaParam(expr_mat, pathways_hallmark)
ssgsea_hallmark <- gsva(param_hallmark, verbose = FALSE)

# run GSVA on C2 and C6 for comprehensive coverage
param_c2 <- ssgseaParam(expr_mat, pathways_c2)
ssgsea_c2 <- gsva(param_c2, verbose = FALSE)

param_c6 <- ssgseaParam(expr_mat, pathways_c6) 
ssgsea_c6 <- gsva(param_c6, verbose = FALSE)

# Correlate ALL factors with ALL pathway collections
correlate_factors_pathways <- function(factor_mat, pathway_mat, pathway_name) {
  common_samples <- intersect(rownames(factor_mat), colnames(pathway_mat))
  factor_aligned <- factor_mat[common_samples, ]
  pathway_aligned <- t(pathway_mat[, common_samples])
  
  cor_matrix <- cor(factor_aligned, pathway_aligned, method = "spearman")
  return(cor_matrix)
}

# Get factor matrix (samples x factors)
fmat <- get_factors(mofa_object.trained, factors = "all", as.data.frame = FALSE)[[1]]

# Compute correlations
hallmark_cor <- correlate_factors_pathways(fmat, ssgsea_hallmark, "Hallmark")
c2_cor <- correlate_factors_pathways(fmat, ssgsea_c2, "C2")
c6_cor <- correlate_factors_pathways(fmat, ssgsea_c6, "C6")

# Find top correlated pathways for each factor
interpret_factors <- function(cor_matrix, pathways, n_top = 20) {
  factor_interpretations <- list()
  
  for(i in 1:nrow(cor_matrix)) {
    factor_cor <- cor_matrix[i, ]
    # Get top positive and negative correlations
    top_pos <- head(sort(factor_cor, decreasing = TRUE), n_top)
    top_neg <- head(sort(factor_cor, decreasing = FALSE), n_top)
    
    factor_interpretations[[rownames(cor_matrix)[i]]] <- list(
      positive_pathways = names(top_pos),
      positive_cor = top_pos,
      negative_pathways = names(top_neg), 
      negative_cor = top_neg
    )
  }
  return(factor_interpretations)
}

hallmark_interpret <- interpret_factors(hallmark_cor, pathways_hallmark)
c2_interpret <- interpret_factors(c2_cor, pathways_c2)
c6_interpret <- interpret_factors(c6_cor, pathways_c6)



```




# Latent Factor Visualization



## geom_col plot

```{r}
## geom_col plot

# Function to return individual plots
plot_factor_separate <- function(factor_id,
                                 gsea_collection = "hallmark",
                                 gsva_collection = "hallmark",
                                 max_pathways = 10) {
  
  plots <- list()
  
  # --- GSEA ---
  p_gsea <- plot_gsea(factor_id, gsea_collection, max_pathways)
  if (!is.null(p_gsea)) {
    p_gsea <- p_gsea +
      theme_minimal() +
      theme(
        axis.text.y = element_text(size = 9, hjust = 1),
        axis.title = element_blank(),
        plot.margin = margin(5, 10, 5, 50)
      ) +
      ggtitle(paste("Factor:", factor_id, "- GSEA"))
  } else {
    p_gsea <- ggplot() + theme_void() + ggtitle(paste(factor_id, "GSEA missing"))
  }
  plots[["GSEA"]] <- p_gsea
  
  # --- GSVA ---
  p_gsva <- plot_gsva(factor_id, gsva_collection, max_pathways)
  if (!is.null(p_gsva)) {
    p_gsva <- p_gsva +
      theme_minimal() +
      theme(
        axis.text.y = element_text(size = 4, hjust = 1),
        axis.title = element_blank(),
        plot.margin = margin(5, 10, 5, 50)
      ) +
      ggtitle(paste("Factor:", factor_id, "- GSVA"))
  } else {
    p_gsva <- ggplot() + theme_void() + ggtitle(paste(factor_id, "GSVA missing"))
  }
  plots[["GSVA"]] <- p_gsva
  
  return(plots)
}

# Factors to plot
top_factors <- c("Factor1", "Factor2", "Factor3")

# Generate and print each plot separately
for (f in top_factors) {
  plots <- plot_factor_separate(f, gsea_collection = "c2", gsva_collection = "c2", max_pathways = 8)
  
  print(plots[["GSEA"]])
  print(plots[["GSVA"]])
}
```




## Heatmap plot


```{r}
# GSEA heatmap for Hallmark pathways
plot_gsea_heatmap("hallmark", top_n_pathways = 30)

# GSVA heatmap for Hallmark pathways
plot_gsva_heatmap("hallmark", top_n_pathways = 20)

# You can switch to "c2" or "c6"
plot_gsea_heatmap("c2", top_n_pathways = 20)
plot_gsva_heatmap("c2", top_n_pathways = 20)



```


# Table

```{r}
# ---- Integrated interpret_factor function ----
interpret_factor <- function(factor_id,
                             top_n_pathways = 5,
                             top_n_genes = 10,
                             gsva_collections = c("hallmark","c2","c6"),
                             gsea_collections = c("hallmark","c2","c6")) {
  
  # --- Top genes ---
  all_weights <- get_weights(mofa_object.trained, views="RNASeq", factors=factor_id, as.data.frame=TRUE)
  top_genes <- head(all_weights[order(-abs(all_weights$value)), ], top_n_genes)
  
  # --- FGSEA ---
  gsea_summary <- list()
  ranks <- setNames(all_weights$value, all_weights$feature)
  ranks <- sort(ranks, decreasing = TRUE)
  
  if("hallmark" %in% gsea_collections) {
    res <- fgsea(pathways_hallmark, ranks, minSize=15, maxSize=500)
    gsea_summary$hallmark <- if(nrow(res) > 0) res[order(res$pval), ][1:top_n_pathways, ] else NULL
  }
  if("c2" %in% gsea_collections) {
    res <- fgsea(pathways_c2, ranks, minSize=15, maxSize=500)
    gsea_summary$c2 <- if(nrow(res) > 0) res[order(res$pval), ][1:top_n_pathways, ] else NULL
  }
  if("c6" %in% gsea_collections) {
    res <- fgsea(pathways_c6, ranks, minSize=15, maxSize=500)
    gsea_summary$c6 <- if(nrow(res) > 0) res[order(res$pval), ][1:top_n_pathways, ] else NULL
  }
  
  # --- GSVA correlations ---
  gsva_summary <- list()
  if("hallmark" %in% gsva_collections) gsva_summary$hallmark <- hallmark_interpret[[factor_id]]
  if("c2" %in% gsva_collections)       gsva_summary$c2 <- c2_interpret[[factor_id]]
  if("c6" %in% gsva_collections)       gsva_summary$c6 <- c6_interpret[[factor_id]]
  
  list(
    top_genes = top_genes,
    gsea_summary = gsea_summary,
    gsva_summary = gsva_summary
  )
}

create_summary_table <- function(factor_ids = paste0("Factor", 1:10),
                                 top_n_pathways = 5,
                                 top_n_genes = 10,
                                 interpretations = NULL) {
  
  # Pre-define all possible columns to ensure consistency
  all_gsea_cols <- c("Top_HALLMARK_GSEA_Pathways", "Top_C2_GSEA_Pathways", "Top_C6_GSEA_Pathways")
  all_gsva_cols <- c("Top_HALLMARK_GSVA_Pathways", "Top_C2_GSVA_Pathways", "Top_C6_GSVA_Pathways")
  
  reports <- lapply(factor_ids, function(fid) {
    
    # ---- Get interpretation outputs ----
    out <- interpret_factor(fid,
                            top_n_pathways = top_n_pathways,
                            top_n_genes = top_n_genes)
    
    # ---- Top genes ----
    top_genes_text <- NA
    if(!is.null(out$top_genes) && nrow(out$top_genes) > 0) {
      top_genes_vec <- as.character(out$top_genes$feature)
      if(is.list(top_genes_vec)) top_genes_vec <- unlist(top_genes_vec)
      top_genes_text <- paste(head(top_genes_vec, top_n_genes), collapse = ", ")
    }
    
    # ---- GSEA columns ----
    gsea_cols <- setNames(rep(NA, length(all_gsea_cols)), all_gsea_cols)
    
    for(col in names(out$gsea_summary)) {
      col_name <- paste0("Top_", toupper(col), "_GSEA_Pathways")
      res <- out$gsea_summary[[col]]
      if(!is.null(res) && nrow(res) > 0) {
        res <- res[order(res$pval), , drop = FALSE]
        res <- head(res, min(top_n_pathways, nrow(res)))
        gsea_cols[col_name] <- paste(res$pathway, "(p=", signif(res$pval, 2), ")", collapse = "; ")
      }
    }
    
    # ---- GSVA columns ----
    gsva_cols <- setNames(rep(NA, length(all_gsva_cols)), all_gsva_cols)
    
    for(col in names(out$gsva_summary)) {
      col_name <- paste0("Top_", toupper(col), "_GSVA_Pathways")
      cor_vec <- out$gsva_summary[[col]]
      if(!is.null(cor_vec) && length(cor_vec) > 0) {
        # Ensure we have a named numeric vector
        if(is.data.frame(cor_vec)) {
          if(ncol(cor_vec) == 1) {
            cor_vec <- setNames(cor_vec[,1], rownames(cor_vec))
          } else {
            cor_vec <- setNames(cor_vec[,1], rownames(cor_vec)) # Take first column
          }
        }
        if(is.list(cor_vec)) cor_vec <- unlist(cor_vec)
        
        # Get top correlations
        if(length(cor_vec) > 0 && !is.null(names(cor_vec))) {
          top_cor <- head(sort(cor_vec, decreasing = TRUE), top_n_pathways)
          gsva_cols[col_name] <- paste(names(top_cor), "[cor=", signif(top_cor, 2), "]", collapse = "; ")
        }
      }
    }
    
    # ---- Combine all into one row ----
    result_row <- data.frame(
      Factor = fid,
      Top_Genes = top_genes_text,
      Interpretation = if(!is.null(interpretations) && fid %in% names(interpretations)) interpretations[[fid]] else NA,
      stringsAsFactors = FALSE
    )
    
    # Add GSEA and GSVA columns in consistent order
    for(col_name in all_gsea_cols) {
      result_row[[col_name]] <- gsea_cols[col_name]
    }
    for(col_name in all_gsva_cols) {
      result_row[[col_name]] <- gsva_cols[col_name]
    }
    
    return(result_row)
  })
  
  # Combine all rows
  final_table <- do.call(rbind, reports)
  return(final_table)
}


# Add the interpretation based on the table
interpretations <- list(
  Factor1 = "Oncogenic proliferation program characterized by MYC/E2F-driven cell cycle activity, KRAS/TGF-β signaling, and smooth muscle/stromal gene expression (MYH11, DES, CNN1)",
  
  Factor2 = "oxidative stress response with immune activation features (allograft rejection, interferon signaling) and angiogenesis regulation",
  
  Factor3 = "Metabolic reprogramming program centered on oxidative phosphorylation and myogenesis, with epithelial-mesenchymal transition and coagulation pathway activation",
  
  Factor4 = "Mitotic and metabolic axis featuring spindle assembly, oxidative phosphorylation, and adipogenesis, with strong autophagy and amino acid metabolism components",
  
  Factor5 = "Advanced cancer progression signature with strong EMT, fatty acid metabolism, and matrisome remodeling, indicative of invasive tumor phenotype",
  
  Factor6 = "Immune-excluded tumor microenvironment characterized by interferon response, glycolytic metabolism, mTOR signaling, and hypoxia adaptation",
  
  Factor7 = "Cell cycle checkpoint and mTOR signaling program with weak immune associations, potentially representing proliferative but immunologically quiet tumors",
  
  Factor8 = "Inflammatory cancer phenotype with EMT, TNFα/NF-κB signaling, KRAS activation, and extracellular matrix organization",
  
  Factor9 = "Antiviral immune response signature featuring strong interferon signaling, cytokine activity (CXCL9, GZMA), and regulated cell death pathways",
  
  Factor10 = "Differentiation and secretory program with EMT, androgen response, protein secretion, and weak WNT/β-catenin signaling"
)
# 1. Create the table data first
all_factors_table <- create_summary_table(
  factor_ids = paste0("Factor", 1:10),
  top_n_pathways = 5,
  top_n_genes = 10,
  interpretations = interpretations
)

```




# Interpretation Report

```{r}
# Interpretation Report

rmd_html <- "MOFA_factor_summary.Rmd"

writeLines(c(
  "---",
  "title: '<center>MOFA Factor Analysis: Biological Pathway Associations</center>'",
  "output:",
  "  html_document:",
  "    toc: true",
  "    toc_float: true",
  "    toc_depth: 3",
  "    number_sections: true",
  "    theme: journal",
  "    css: styles.css",
  "    df_print: paged",
  "---",
  "",
  "```{r setup, include=FALSE}",
  "knitr::opts_chunk$set(",
  "  echo = FALSE, warning = FALSE, message = FALSE,",
  "  fig.align = 'center',",
  "  fig.width = 7, fig.height = 5,",
  "  out.width = '100%',",
  "  fig.show = 'asis'   # ensure plots are printed one below the other",
  ")",
  "library(kableExtra)",
  "library(dplyr)",
  "library(DT)",
  "library(patchwork)",
  "library(ggplot2)",
  "```",
  "",
"<style>",
"@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Merriweather:wght@400;700&display=swap');",
"",
"body {",
"  font-family: 'Roboto', sans-serif;",
"  line-height: 1.7;",
"  color: #2c3e50;",
"  background-color: #fafafa;",
"  max-width: 1100px;",
"  margin: auto;",
"  padding: 20px;",
"}",
"h1, h2, h3 {",
"  font-family: 'Merriweather', serif;",
"  color: #1a5276;",
"  margin-top: 2em;",
"  padding-bottom: 0.3em;",
"  border-bottom: 2px solid #5dade2;",
"}",
"table {",
"  border-collapse: collapse;",
"  margin: 1em 0;",
"}",
"th {",
"  background-color: #5dade2;",
"  color: #fff;",
"  padding: 8px;",
"  text-align: left;",
"}",
"td {",
"  padding: 8px;",
"  border-bottom: 1px solid #ddd;",
"}",
".table-caption {",
"  font-weight: 600;",
"  font-size: 1.1em;",
"  color: #34495e;",
"  margin-bottom: 8px;",
"}",
"code, pre {",
"  font-family: 'Fira Code', monospace;",
"  background-color: #f4f6f6;",
"  padding: 2px 6px;",
"  border-radius: 4px;",
"}",
"</style>",
  "",
  "# Introduction",
  "",
  "MOFA identifies latent factors that capture coordinated variation across multi-omics datasets. This analysis interprets these factors through their associations with well-curated biological pathways from MSigDB.",
  "",
  "# Data Sources and Analytical Pipeline",
  "- **MOFA Model**: Trained on multi-omics views: Prov-GigaPath WSI Embedding and RNAseq data",
  "- **Pathway Databases**: MSigDB Hallmark, C2 (Curated), C6 (Oncogenic)",
  "- **Analysis Methods**: GSEA (preranked), GSVA (sample-level)",
  "- **Pipeline**:",
  "  1. Extract factor weights from MOFA model",
  "  2. Perform preranked GSEA on factor loadings",
  "  3. Calculate pathway activity scores using GSVA",
  "  4. Correlate factors with pathway activities",
  "",
  "# Latent Factor Visualization",
  "",
  "## Heatmaps",
  "```{r heatmap-plots, fig.width=12, fig.height=10}",
  "if (exists('plot_gsea_heatmap')) {",
  "  print(plot_gsea_heatmap('hallmark', top_n_pathways = 30))",
  "  print(plot_gsva_heatmap('hallmark', top_n_pathways = 20))",
  "  print(plot_gsea_heatmap('c2', top_n_pathways = 30))",
  "  print(plot_gsva_heatmap('c2', top_n_pathways = 20))",
  "  print(plot_gsea_heatmap('c6', top_n_pathways = 20))",
  "  print(plot_gsva_heatmap('c6', top_n_pathways = 20))",
  "}",
  "```",
  "",
  "## Summary of Factor Interpretations",
  "```{r summary-table, results='asis'}",
  "if (exists('all_factors_table')) {",
  "  kable(all_factors_table, format = 'html', escape = FALSE,",
  "        caption = '<strong>Table 1: MOFA Factor Biological Interpretations</strong>') %>%",
  "    kable_styling(",
  "      bootstrap_options = c('striped', 'hover', 'condensed'),",
  "      full_width = TRUE,",
  "      font_size = 12,",
  "      position = 'center'",
  "    ) %>%",
  "    column_spec(1, bold = TRUE, width = '80px') %>%",
  "    column_spec(2, width = '100px') %>%",
  "    column_spec(3, width = '200px') %>%",
  "    column_spec(4:ncol(all_factors_table), width = '250px') %>%",
  "    scroll_box(width = '100%', height = '500px')",
  "}",
  "```",
  "",
  "## Embedding Correlation Summary",
  "",
  "```{r embedding-correlation-table, results='asis'}",
  "if (exists('enhanced_summary')) {",
  "  comprehensive_table <- enhanced_summary %>%",
  "    select(",
  "      Factor = factor,",
  "      `Best Embedding` = best_embedding,",
  "      Correlation = correlation,",
  "      `Top Positive Pathway` = top_positive_pathway_clean,",
  "      `Top Negative Pathway` = top_negative_pathway_clean,",
  "      `Top RNA Genes` = top_rna_genes",
  "    ) %>%",
  "    arrange(desc(abs(Correlation)))",
  "",
  "  kable(comprehensive_table, format = 'html', escape = FALSE,",
  "        caption = '<strong>Table 2: Correlations Between MOFA Factors and Image Embeddings</strong>') %>%",
  "    kable_styling(",
  "      bootstrap_options = c('striped', 'hover', 'condensed'),",
  "      full_width = TRUE,",
  "      font_size = 12,",
  "      position = 'center'",
  "    ) %>%",
  "    column_spec(1, bold = TRUE, width = '100px') %>%",
  "    column_spec(2, width = '150px') %>%",
  "    column_spec(3, width = '100px') %>%",
  "    column_spec(4:6, width = '250px') %>%",
  "    scroll_box(width = '100%', height = '500px')",
  "}",
  "```",
  "",
  "## Factor Enrichment Plots",
  "```{r factor-enrichment, fig.width=12, fig.height=12}",
  "top_n_enrichment <- 3",
  "for(f in top_factors) {",
  "  enrichment_plot <- plot_factor_enrichment(f, pathway_collection='hallmark', top_n=top_n_enrichment, all_weights=all_weights)",
  "  if(!is.null(enrichment_plot)) print(enrichment_plot[[1]])",
  "}",
  "```"
), con = rmd_html)

# Render HTML
rmarkdown::render(rmd_html ,output_file = "MOFA_factor_summary.html")
```


```{r}
# =========================================================
# Fast MOFA Factor HTML Report with Precomputed Tables
# =========================================================

rmd_html <- "MOFA_factor_summary_fast.Rmd"

writeLines(c(
  "---",
  "title: '<center>MOFA Factor Analysis: Biological Pathway Associations</center>'",
  "output:",
  "  html_document:",
  "    toc: true",
  "    toc_float: true",
  "    toc_depth: 3",
  "    number_sections: true",
  "    theme: journal",
  "    css: styles.css",
  "    df_print: paged",
  "---",
  "",
  "```{r setup, include=FALSE}",
  "knitr::opts_chunk$set(",
  "  echo = FALSE, warning = FALSE, message = FALSE,",
  "  fig.align = 'center',",
  "  fig.width = 7, fig.height = 5,",
  "  out.width = '100%',",
  "  fig.show = 'asis'",
  ")",
  "library(kableExtra)",
  "library(dplyr)",
  "library(DT)",
  "library(patchwork)",
  "library(ggplot2)",
  "```",
  "",
  "<style>",
  "@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Merriweather:wght@400;700&display=swap');",
  "body { font-family: 'Roboto', sans-serif; line-height: 1.7; color: #2c3e50; background-color: #fafafa; max-width: 1100px; margin: auto; padding: 20px; }",
  "h1, h2, h3 { font-family: 'Merriweather', serif; color: #1a5276; margin-top: 2em; padding-bottom: 0.3em; border-bottom: 2px solid #5dade2; }",
  "table { border-collapse: collapse; margin: 1em 0; }",
  "th { background-color: #5dade2; color: #fff; padding: 8px; text-align: left; }",
  "td { padding: 8px; border-bottom: 1px solid #ddd; }",
  ".table-caption { font-weight: 600; font-size: 1.1em; color: #34495e; margin-bottom: 8px; }",
  "code, pre { font-family: 'Fira Code', monospace; background-color: #f4f6f6; padding: 2px 6px; border-radius: 4px; }",
  "</style>",
  "",
  "# Introduction",
  "MOFA identifies latent factors that capture coordinated variation across multi-omics datasets. This analysis interprets these factors through their associations with curated biological pathways.",
  "",
  "# Data Sources and Pipeline",
  "- **Precomputed Tables**: all_factors_table.rds, enhanced_summary.rds",
  "- **Analysis Methods**: GSEA (preranked), GSVA (sample-level)",
  "",
  "# Latent Factor Tables",
  "",
  "## Summary of Factor Interpretations",
  "```{r summary-table, results='asis'}",
  "all_factors_table <- readRDS('all_factors_table.rds')",
  "if (exists('all_factors_table')) {",
  "  kable(all_factors_table, format = 'html', escape = FALSE,",
  "        caption = '<strong>Table 1: MOFA Factor Biological Interpretations</strong>') %>%",
  "    kable_styling(bootstrap_options = c('striped','hover','condensed'), full_width = TRUE, font_size = 12, position = 'center') %>%",
  "    column_spec(1, bold = TRUE, width = '80px') %>%",
  "    column_spec(2, width = '100px') %>%",
  "    column_spec(3, width = '200px') %>%",
  "    column_spec(4:ncol(all_factors_table), width = '250px') %>%",
  "    scroll_box(width = '100%', height = '500px')",
  "}",
  "```",
  "",
  "## Embedding Correlation Summary",
  "```{r embedding-correlation-table, results='asis'}",
  "enhanced_summary <- readRDS('enhanced_summary.rds')",
  "if (exists('enhanced_summary')) {",
  "  comprehensive_table <- enhanced_summary %>%",
  "    select(Factor = factor, `Best Embedding` = best_embedding, Correlation = correlation,",
  "           `Top Positive Pathway` = top_positive_pathway_clean,",
  "           `Top Negative Pathway` = top_negative_pathway_clean,",
  "           `Top RNA Genes` = top_rna_genes) %>%",
  "    arrange(desc(abs(Correlation)))",
  "",
  "  kable(comprehensive_table, format = 'html', escape = FALSE,",
  "        caption = '<strong>Table 2: Correlations Between MOFA Factors and Image Embeddings</strong>') %>%",
  "    kable_styling(bootstrap_options = c('striped','hover','condensed'), full_width = TRUE, font_size = 12, position = 'center') %>%",
  "    column_spec(1, bold = TRUE, width = '100px') %>%",
  "    column_spec(2, width = '150px') %>%",
  "    column_spec(3, width = '100px') %>%",
  "    column_spec(4:6, width = '250px') %>%",
  "    scroll_box(width = '100%', height = '500px')",
  "}",
  "```"
), con = rmd_html)

# Render HTML
rmarkdown::render(rmd_html, output_file = "MOFA_factor_summarys.html")
```



* Factor 1 represents a proliferative, MYC-driven program enriched for E2F targets, KRAS signaling, and EMT pathways, reflecting high cell-cycle activity and transcriptional programs associated with tumor growth. In the context of colorectal cancer, it likely marks aggressive, mesenchymal-like tumors with enhanced proliferation, invasion, and metastatic potential.



#### Surv analysis

* The clinical features have 5 dimensions: T stage, N stage, M stage, total stage, and whether or not to receive chemotherapy after surgery [1]

[1] Cai, C., Zhou, Y., Jiao, Y. et al. Prognostic Analysis Combining Histopathological Features and Clinical Information to Predict Colorectal Cancer Survival from Whole-Slide Images. Dig Dis Sci 69, 2985–2995 (2024). https://doi-org.ccny-proxy1.libr.ccny.cuny.edu/10.1007/s10620-024-08501-x



```{r}
# ==============================
# Survival Analysis: MOFA + GSVA + Clinical
# ==============================
# -----------------------------
# 1. Load metadata and MOFA factors
# -----------------------------
meta <- samples_metadata(mofa_object.trained)

# Compute survival time
meta$time <- ifelse(meta$vital_status.x == 1, 
                    meta$days_to_death.x,
                    pmax(meta$patient.days_to_last_followup,
                         meta$patient.days_to_last_known_alive,
                         na.rm = TRUE))
meta$time <- pmax(meta$time, 0)  # ensure non-negative
meta$event <- meta$vital_status.x  # 1 = death, 0 = censored

cat("Event counts:\n")
print(table(meta$event, useNA="ifany"))

# -----------------------------
# 2. Kaplan-Meier by histological type
# -----------------------------
km_fit_hist <- survfit(Surv(time, event) ~ patient.stage_event.tnm_categories.pathologic_categories.pathologic_t,
                       data = meta)
ggsurvplot(
  km_fit_hist, data = meta,
  risk.table = TRUE,
  pval = TRUE,
  palette = "Dark2",
  title = "Kaplan-Meier Survival by Histological Type",
  xlab = "Days",
  ylab = "Survival Probability"
)

# -----------------------------
# 3. Extract and align MOFA factors
# -----------------------------
fmat <- get_factors(mofa_object.trained, factors = "all", as.data.frame = FALSE)[[1]]
common_samples <- intersect(rownames(meta), rownames(fmat))
meta2 <- meta[common_samples, , drop = FALSE]
fmat2 <- fmat[common_samples, , drop = FALSE]

# Attach all factors as numeric
for(i in 1:5){
  meta2[[paste0("factor", i)]] <- as.numeric(fmat2[, i])
}

# -----------------------------
# 4. Attach top GSVA pathways per factor
# -----------------------------
# Top 3 pathways per factor from correlation matrix
top_per_factor <- apply(abs(cor_matrix), 1, function(x) names(sort(x, decreasing = TRUE))[1:3])
cand_pathways <- unique(as.vector(top_per_factor))

# Extract these pathways from pathway_df and align
cand_pathways_df <- pathway_df[, cand_pathways, drop=FALSE]
common_samples <- intersect(rownames(meta2), rownames(cand_pathways_df))
meta2 <- meta2[common_samples, ]
cand_pathways_df <- cand_pathways_df[common_samples, ]
meta2 <- cbind(meta2, cand_pathways_df)




```

#### Univariable Cox regression
```{r}
# -----------------------------
# 5. Define candidate variables
# -----------------------------
clinical_vars <- c("age", "sex", "pathology_T_stage", "pathology_N_stage", 
                   "pathology_M_stage", "patient.stage_event.tnm_categories.pathologic_categories.pathologic_t")
factor_vars <- paste0("factor", 1:5)
cand_vars <- c(clinical_vars, factor_vars, cand_pathways)
cand_vars <- cand_vars[cand_vars %in% colnames(meta2)]

# -----------------------------
# 6. Univariable Cox regression
# -----------------------------
univ_results <- lapply(cand_vars, function(v){
  form <- as.formula(paste0("Surv(time, event) ~ `", v, "`"))
  m <- tryCatch(coxph(form, data = meta2), error = function(e) NULL)
  if(is.null(m)) return(data.frame(var=v, HR=NA, p=NA))
  s <- summary(m)
  data.frame(var=v, HR=exp(s$coef[1,"coef"]), p=s$coef[1,"Pr(>|z|)"], stringsAsFactors=FALSE)
})
univ_results <- do.call(rbind, univ_results)
univ_results <- univ_results %>% arrange(p)

# Inspect univariable results
univ_results




```

#### Multivariable Cox regression
```{r}
# -----------------------------
# 7. Multivariable Cox regression
# -----------------------------
# Select top factors, pathways, and clinical covariates based on univariable p < 0.05
top_factors <- c("factor1","factor2","factor3","factor4")  # example
top_pathways <- c("HALLMARK_MITOTIC_SPINDLE",
                  "HALLMARK_PI3K_AKT_MTOR_SIGNALING",
                  "HALLMARK_SPERMATOGENESIS")  # example
clin_vars <- c("pathology_M_stage")  # example
mv_vars <- c(top_factors, top_pathways, clin_vars)
mv_vars <- mv_vars[mv_vars %in% colnames(meta2)]

# Standardize continuous variables for Cox
num_vars <- mv_vars[sapply(meta2_std[, mv_vars], is.numeric)]

for(v in num_vars){
  meta2_std[[v]] <- as.numeric(scale(meta2_std[[v]]))
}

# Fit multivariable Cox model
cox_formula <- as.formula(paste0("Surv(time, event) ~ ", paste(mv_vars, collapse = " + ")))
cox_mv <- coxph(cox_formula, data = meta2_std)
summary(cox_mv)
```


