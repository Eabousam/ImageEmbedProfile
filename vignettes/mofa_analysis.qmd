---
title: "Multi-Omics Factor Analysis (MOFA) & preranked Gene Enrichment (GSEA) Cancer Imaging"
format: 
  html:
    theme: yeti
    highlight-style: tango
    toc: true
    toc-depth: 3
    toc-floating: true
editor: visual
execute:
  echo: false
  warning: false
  message: false
  include: false
  results: "hide"
  fig-width: 10
  fig-height: 8
  fig-dpi: 300
editor_options: 
  chunk_output_type: inline
---

## Libraries

```{r setup, include=FALSE}
# Load required libraries
library(MOFA2)
library(survival)
library(survminer)
library(curatedTCGAData)
library(fgsea)
library(msigdbr)  
library(enrichplot)
library(ggplot2)
library(dplyr)
library(genekitr)
library(GSVA)
library(Hmisc)
library(pheatmap)
library(DT)
library(tidyverse)
library(kableExtra)

devtools::load_all()

```

#### Analyze MOFA model

```{r, include =TRUE, echo = TRUE}
#| label: load-mofa
# Load trained MOFA model

#mofa_object.trained <- readRDS("mofa_model_with_metadata.rds")
mofa_object.trained <- readRDS("mofa_model_lastembed_with_metadata.rds")
# visualize the model views and samples
plot_data_overview(mofa_object.trained)
samples_metadata(mofa_object.trained) <- metadata_matched
names(metadata_matched)
# Plot factor correlations to check for interdependence issues with the model
plot_factor_cor(mofa_object.trained)


# Plot variance explained
plot_variance_explained(mofa_object.trained, plot_total = TRUE)

print(mofa_object.trained@cache$variance_explained)



```

#### Initial visualizations

```{r}
#| label: mofa-visualization
#| warning: false




# Plot data heatmaps
# using rna seq view
plot_data_heatmap(mofa_object.trained,
                   scale = "row",
                   cluster_cols = FALSE,
                   cluster_rows = FALSE,
                   show_colnames = FALSE,
                   denoise = TRUE,
                   features = 10,
                   view = "RNASeq",
                   factor=1)

# Using embedding view
plot_data_heatmap(mofa_object.trained,
                  factor = 1,
                  view = "Embedding_last",
                  features = 10,
                  cluster_rows = FALSE,
                  cluster_cols = FALSE,
                  show_colnames = FALSE)

# Plot top weights 
plot_top_weights(mofa_object.trained,
                 view = "RNASeq",
                 factor = 1,
                 nfeatures = 10)


# Plot factor colored by pathology stage
plot_factor(mofa_object.trained, 
            factor = 1, 
            add_violin = T,
            dodge = TRUE,
            color_by = "MYH11")

# Plot factor scatter
plot_factor(mofa_object.trained, 
            factor = c(1, 2), 
            color_by = "pathology_T_stage")

plot_top_weights(mofa_object.trained,
                 view = "Embedding_last",
                 factor = 1,
                 nfeatures = 10)

# Correlate factors with clinical variables
correlate_factors_with_covariates(mofa_object.trained, 
                      covariates = c("vital_status.x","pathology_M_stage","tumor_tissue_site"), 
                      plot = "log_pval" )



```

# Factor Contribution

```{r}
# ================================
# Factor Contribution Analysis
# ================================

# 1. Extract loadings (factor weights) for each view
#    MOFA provides loadings per view (e.g. RNASeq, embeddings).
loadings_rnaseq_list <- get_weights(mofa_object.trained, views = "RNASeq")
loadings_embed_list  <- get_weights(mofa_object.trained, views = "Embedding_layer0")

# 2. Convert lists of loadings into numeric matrices
#    Each column corresponds to a factor; each row to a feature (gene, embedding dim).
loadings_rnaseq <- do.call(cbind, loadings_rnaseq_list)
loadings_embed  <- do.call(cbind, loadings_embed_list)

# 3. Compute per-factor contribution
#    Take the sum of *absolute* loadings for each factor.
#    - Absolute value ensures negative/positive weights contribute equally.
#    - This gives a "total magnitude of influence" per factor.
abs_sum_rnaseq <- colSums(abs(loadings_rnaseq))    # RNASeq
abs_sum_embed  <- colSums(abs(loadings_embed))     # Embedding

# 4. Organize results into tidy format for plotting
abs_sum_df <- data.frame(
  Factor    = 1:length(abs_sum_rnaseq),   # factor index
  RNASeq    = abs_sum_rnaseq,
  Embedding = abs_sum_embed
) %>%
  pivot_longer(
    cols = c("RNASeq", "Embedding"), 
    names_to = "View", 
    values_to = "AbsSum"
  )

# 5. Plot per-factor absolute contributions
#    Shows how much each factor is "used" within each view.
ggplot(abs_sum_df, aes(x = Factor, y = AbsSum, fill = View)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = c("RNASeq" = "blue", "Embedding" = "orange")) +
  labs(
    title = "Sum of Absolute Loadings per Factor",
    x = "Factor",
    y = "Sum of Absolute Loadings"
  ) +
  theme_minimal()

# 6. Compute cumulative contribution across factors
#    Cumulative sum shows how much variance/information is captured
#    as more factors are included in order (Factor1 → Factor15).
cum_sum_rnaseq <- cumsum(abs_sum_rnaseq)
cum_sum_embed  <- cumsum(abs_sum_embed)

# 7. Organize cumulative results into tidy format
cum_sum_df <- data.frame(
  Factor    = 1:length(cum_sum_rnaseq),
  RNASeq    = cum_sum_rnaseq,
  Embedding = cum_sum_embed
) %>%
  pivot_longer(
    cols = c("RNASeq", "Embedding"), 
    names_to = "View", 
    values_to = "Cumsum"
  )

# 8. Plot cumulative contribution
#    Line plot shows the growth of total contribution as factors accumulate.
ggplot(cum_sum_df, aes(x = Factor, y = Cumsum, color = View)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  labs(
    title = "Cumulative Sum of Absolute Loadings Across Factors",
    x = "Factor",
    y = "Cumulative Sum of Absolute Loadings"
  ) +
  theme_minimal()
```

```{r}
plot_weights(mofa_object.trained, 
             view = 2, 
             factor = 3, 
             nfeatures = 10)
# if we have tile embeddings with some coords, we can figure out where they are in the slide image??
```

# PCA interpretation

### Matrices

```{r}
#==============================================================
# 1. Get factor scores
#==============================================================
factor_scores <- get_factors(mofa_object.trained, factors = "all", as.data.frame = FALSE)[[1]] %>%
  as.data.frame() %>%
  tibble::rownames_to_column("patient_id")

#==============================================================
# 2. Load embeddings (last layer only)
#==============================================================
devtools::load_all()  # contains getEmbeddingLayer()

participant_ids <- gsub(".csv$", "", basename(fnames)) %>% 
  strsplit(., "-") %>% 
  sapply(\(x) paste(x[1:3], collapse = "-"))

structure_last <- getEmbeddingLayer(fnames, participant_ids, layer = "last_layer_embed")

#==============================================================
# 3. Align patients between MOFA factors and embeddings
#==============================================================
shared_ids <- intersect(rownames(structure_last), factor_scores$patient_id)

embedding_matched <- structure_last[shared_ids, , drop = FALSE]
factor_scores_matched <- factor_scores[factor_scores$patient_id %in% shared_ids, ]
rownames(factor_scores_matched) <- factor_scores_matched$patient_id
factor_scores_matched <- factor_scores_matched[shared_ids, , drop = FALSE]

#==============================================================
# 4. Table 1: Correlation (factors × embedding dims)
#==============================================================
cor_mat <- cor(
  factor_scores_matched[, -1],
  embedding_matched,
  use = "pairwise.complete.obs"
)

embedding_corr_table <- as.data.frame(cor_mat) %>%
  tibble::rownames_to_column("Factor") %>%
  tidyr::pivot_longer(-Factor,
                      names_to = "Embedding_Dimension",
                      values_to = "Correlation") %>%
  dplyr::mutate(Abs_Corr = abs(Correlation)) %>%
  dplyr::arrange(Factor, desc(Abs_Corr))

#==============================================================
# 5. Table 2: Top weighted embeddings from MOFA
#==============================================================
embedding_weights <- get_weights(mofa_object.trained, view = "Embedding_last", as.data.frame = FALSE)[[1]]

embedding_weight_table <- lapply(seq_len(ncol(embedding_weights)), function(f) {
  tibble::tibble(
    Factor = colnames(embedding_weights)[f],
    Embedding_Dimension = rownames(embedding_weights),
    Weight = embedding_weights[, f],
    Abs_Weight = abs(embedding_weights[, f])
  ) %>%
    dplyr::arrange(desc(Abs_Weight)) %>%
    dplyr::slice_head(n = 20)  # top 20 per factor
}) %>%
  dplyr::bind_rows()

#==============================================================
# Outputs
#==============================================================
head(embedding_corr_table)
head(embedding_weight_table)
```



# Exploring Embeddings

```{r}
# PCA on embeddings
pca_res <- prcomp(embedding_matched, scale. = TRUE)

# Examine variance explained
summary(pca_res)

# Get sample scores (N x components)
pca_scores <- as.data.frame(pca_res$x)
head(pca_scores)

# Correlate PCA components with MOFA factor scores
pca_factor_cor <- cor(pca_scores, factor_scores_matched[, -1], use = "pairwise.complete.obs")


# visualize first two PCs
ggplot(pca_scores, aes(PC1, PC2)) +
  geom_point(color = "gray40") +
  theme_minimal() +
  labs(title = "PCA of Image Embeddings",
       x = paste0("PC1 (", round(summary(pca_res)$importance[2,1]*100, 1), "% var)"),
       y = paste0("PC2 (", round(summary(pca_res)$importance[2,2]*100, 1), "% var)"))

ggplot(pca_scores %>% cbind(df), aes(PC1, PC2, color = cluster)) + geom_point()


```



```{r}
# Clinical variables to test
clin_vars <- c("tumor_tissue_site", "gender", "histological_type",
              "patient.vital_status", "patient.anatomic_neoplasm_subdivision",
              "pathologic_stage")

# Initialize list to store R² results
r2_results <- list()

for (v in clin_vars) {
  if (!v %in% names(df)) next
  r2_vec <- sapply(names(pca_scores), function(pc) {
    f <- as.formula(paste(pc, "~", v))
    mod <- lm(f, data = cbind(df, pca_scores))
    summary(mod)$r.squared
  })
  r2_results[[v]] <- data.frame(
    PC = names(pca_scores),
    R2 = r2_vec,
    variable = v
  )
}

r2_df <- do.call(rbind, r2_results)  %>%
  dplyr::filter(as.numeric(gsub("PC", "", PC)) <= 60)


# Plot
r2_df$PC <- as.numeric(gsub("PC", "", r2_df$PC))

ggplot(r2_df, aes(x = PC, y = R2, color = variable, group = variable)) +
  geom_line() +
  geom_point(size = 1.2) +
  scale_x_continuous(
    breaks = seq(0, 60, 10),
    labels = seq(0, 60, 10),
    expand = c(0, 0)
  ) +
  theme_bw(base_size = 12) +
  theme(
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 0, vjust = 0.5)
  ) +
  labs(
    title = "Variance in PCA Components Explained by Clinical Variables",
    x = "PC",
    y = expression(R^2 ~ " (from linear model)")
  )

```




# Projection of embeddings

```{r}
# matrices
X <- as.matrix(embedding_matched)                 # N x D
Y <- as.matrix(factor_scores_matched[ , -1 ])     # N x F

# center/scale X and Y as needed
Xs <- scale(X)          # mean 0, sd 1
Ys <- scale(Y)

W <- as.matrix(embedding_weights)    # D x F (rownames = embedding dims, colnames = Factor names)

# choose factor j (or loop)
j <- "Factor3"
w_j <- W[, j]                        # length D

# project each sample into that MOFA-derived direction
proj_wj <- Xs %*% w_j                # N x 1

# compare to factor scores
cor(proj_wj, Ys[, j])
plot(
  Ys[, j], proj_wj,
  xlab = paste("MOFA factor", j, "score"),
  ylab = "Projection on embedding weights",
  main = paste("Embedding–Factor association:", j),
  pch = 16, col = "gray40"
)
abline(lm(proj_wj ~ Ys[, j]), col = "red", lwd = 2)


heatmap(embedding_weights, scale = "row",
        xlab = "MOFA factors", ylab = "Embedding dimensions",
        main = "Embedding–Factor weight structure")



```


# Analyse clusters of embeddings projection Factor 3

```{r}

library(dplyr)
library(ggplot2)
library(glue)

# --- 1. Cluster assignment and merge metadata
proj <- Xs %*% W[, "Factor3"]

# kmeans ** note: could use other clustering methods

# run k-means on the projection or embeddings
km <- kmeans(proj, centers = 2, nstart = 20)

# build dataframe
factor3_cluster_df <- data.frame(
  sample_id = rownames(Xs),
  projection = as.numeric(proj),
  factor_score = Ys[, "Factor3"],
  cluster = factor(km$cluster)
)

# merge metadata
metadata <- samples_metadata(mofa_object.trained)
factor3_cluster_df <- left_join(factor3_cluster_df, metadata, by = c("sample_id" = "patientID"))

# --- 2. Add GSVA pathways (top 10 pos/neg)
f3 <- hallmark_interpret[["Factor3"]]
pathways <- c(head(f3$positive_pathways, 10), head(f3$negative_pathways, 10))
gsva <- as.data.frame(t(ssgsea_hallmark[pathways, ]))
gsva$sample_id <- rownames(gsva)
df <- left_join(df, gsva, by = "sample_id")

# --- 3. Summarize categorical metadata
cat_vars <- c("tumor_tissue_site", "gender", "histological_type",
              "patient.vital_status", "patient.anatomic_neoplasm_subdivision",
              "pathologic_stage")

cat_summary <- lapply(cat_vars, function(v) {
  if (!v %in% names(df)) return(NULL)
  tab <- table(df$cluster, df[[v]], useNA = "ifany")

  # get the actual cluster names dynamically
  clust_names <- rownames(tab)

  c1 <- paste0(colnames(tab), ": ", as.integer(tab[clust_names[1],]), 
               " (", round(100*tab[clust_names[1],]/sum(tab[clust_names[1],]),1), "%)", collapse="; ")
  c2 <- paste0(colnames(tab), ": ", as.integer(tab[clust_names[2],]), 
               " (", round(100*tab[clust_names[2],]/sum(tab[clust_names[2],]),1), "%)", collapse="; ")

  p <- NA
  test <- NA
  if (all(dim(tab)==c(2,2))) {
    test <- "Fisher"
    p <- tryCatch(fisher.test(tab)$p.value, error=function(e) NA)
  } else if (nrow(tab)==2) {
    test <- "Chi-square"
    p <- tryCatch(chisq.test(tab)$p.value, error=function(e) NA)
  }

  data.frame(variable=v, cluster1=c1, cluster2=c2, test=test, p_value=p)
}) %>% bind_rows()

print(cat_summary)


# Prepare data for plotting
cat_plot_data <- factor3_cluster_df %>%
  select(cluster, all_of(cat_vars)) %>%
  pivot_longer(cols = -cluster, names_to = "variable", values_to = "value") %>%
  group_by(cluster, variable, value) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(variable, cluster) %>%
  mutate(freq = n / sum(n))

# Create one figure per variable
plots <- lapply(unique(cat_plot_data$variable), function(v) {
  ggplot(subset(cat_plot_data, variable == v),
         aes(x = cluster, y = freq, fill = value)) +
    geom_bar(stat = "identity", position = "fill") +
    scale_y_continuous(labels = scales::percent_format()) +
    labs(title = glue("Cluster composition by {v}"), y = "Proportion", x = "Cluster") +
    theme_minimal() +
    theme(legend.position = "bottom", axis.text.x = element_text(angle = 45, hjust = 1))
})

# Display the first plot as example
plots[[1]]

# --- 4. Compare numeric pathways
pathway_vars <- names(factor3_cluster_df)[sapply(df, is.numeric)]
pathway_vars <- setdiff(pathway_vars, c("projection", "factor_score"))

num_summary <- lapply(pathway_vars, function(p) {
  vals1 <- df[[p]][df$cluster=="Cluster1"]
  vals2 <- df[[p]][df$cluster=="Cluster2"]
  mean_diff <- mean(vals1, na.rm=TRUE) - mean(vals2, na.rm=TRUE)
  pval <- NA
  if (var(vals1, na.rm=TRUE) !=0 & var(vals2, na.rm=TRUE)!=0) {
    pval <- tryCatch(t.test(vals1, vals2)$p.value, error=function(e) NA)
  }
  data.frame(pathway=p, mean_diff=mean_diff, p_value=pval)
}) %>% bind_rows() %>% arrange(p_value)

print(head(num_summary, 20))  # top 20 differences


# --- 6. Plot clusters
ggplot(factor3_cluster_df, aes(x=factor_score, y=projection, color=cluster)) +
  geom_point(alpha=0.7) +
  theme_minimal() +
  labs(title="Factor3 clusters", x="MOFA Factor3", y="Projection")




```


# factor 3 Surv cluster
```{R}
# surv

# examine missingness by cluster, is there differential loss to follow up?
factor3_cluster_df %>%
  group_by(cluster) %>%
  summarise(
    n = n(),
    n_dead = sum(patient.vital_status == "dead", na.rm = TRUE),
    n_alive = sum(patient.vital_status == "alive", na.rm = TRUE),
    missing_death = sum(is.na(days_to_death.x)),
    missing_last_followup = sum(is.na(patient.days_to_last_followup)),
    missing_last_alive = sum(is.na(patient.days_to_last_known_alive)),
    zero_followup = sum(patient.days_to_last_followup <= 0, na.rm = TRUE),
    zero_known_alive = sum(patient.days_to_last_known_alive <= 0, na.rm = TRUE)
  )



# Keep only complete cases
surv_df <- factor3_cluster_df %>%
  mutate(
    # Define event from patient.vital_status
    event = ifelse(patient.vital_status == "dead", 1, 0),

    # Compute time:
    # If dead, use days_to_death.x
    # If alive, use the last follow-up available (patient.days_to_last_followup or patient.days_to_last_known_alive)
    time = case_when(
      event == 1 & !is.na(days_to_death.x) ~ days_to_death.x,
      event == 0 & !is.na(patient.days_to_last_followup) & patient.days_to_last_followup > 0 ~ patient.days_to_last_followup,
      event == 0 & !is.na(patient.days_to_last_known_alive) & patient.days_to_last_known_alive > 0 ~ patient.days_to_last_known_alive,
      TRUE ~ NA_real_  # if none available
    ),

    # Clean up other variables
    cluster = factor(cluster),
    age     = patient.age_at_initial_pathologic_diagnosis,
    gender  = factor(patient.gender),
    stage   = factor(patient.stage_event.pathologic_stage),
    site    = factor(tumor_tissue_site),
    hist_type = factor(patient.histological_type)
  ) %>%
  filter(!is.na(time), !is.na(event), !is.na(cluster))



# Range of time variable (should be in days, positive)
range(surv_df$time, na.rm = TRUE)


# Fit KM 
km_fit <- survfit(Surv(time, event) ~ cluster, data = surv_df)

# Plot
ggsurvplot(
   km_fit,
   data = surv_df,
   risk.table = TRUE,
   pval = TRUE,
   conf.int = TRUE,
   palette = c("#E7B800", "#2E9FDF"),
   title = "Kaplan-Meier Survival by Factor3 Projection Cluster",
   xlab = "Time (days)",
   ylab = "Survival Probability"
)


# cox model
table(surv_df$event)

cox_uni <- coxph(Surv(time, event) ~ cluster, data = surv_df)
summary(cox_uni)

# multivariable
cox_fit_multi <- coxph(Surv(time, event) ~ cluster  + age + gender + pathologic_stage + hist_type, data = surv_df)


# test PH assumption
ph_test <- cox.zph(cox_fit_multi)
ph_test
plot(ph_test)        # diagnostic plots for each covariate

# cox table
table(surv_df$hist_type, surv_df$event)
table(surv_df$hist_type, surv_df$cluster)
cox_tbl <- tidy(cox_fit_multi, exponentiate = TRUE, conf.int = TRUE)
cox_tbl <- cox_tbl %>%
  select(term, estimate, conf.low, conf.high, p.value) %>%
  rename(HR = estimate, CI_low = conf.low, CI_high = conf.high, pval = p.value)

cox_tbl
```



# Factor scores and clin vars

```{r}
# Ensure metadata merged correctly
factors_metadata_df <- get_factors(mofa_object.trained, factors = "all", as.data.frame = TRUE) %>%
  inner_join(metadata_df, by = c("sample" = "patientID"))

factors_metadata_df <- factors_metadata_df %>%
  select(sample, factor, value, all_of(clin_vars)) %>%
  pivot_wider(names_from = factor, values_from = value)

# selecting some clinical metadata vars
clin_vars <- c("tumor_tissue_site", "gender", "histological_type",
               "patient.vital_status", "patient.anatomic_neoplasm_subdivision",
               "pathologic_stage")

# empty df for results
r2_df_mofa_factors <- data.frame()

for (var in clin_vars) {
  for (f in grep("^Factor", names(factors_metadata_df), value = TRUE)) {
    y <- as.numeric(factors_metadata_df[[f]])
    x <- factors_metadata_df[[var]]

    if (all(is.na(y)) || length(unique(na.omit(x))) < 2) next

    model <- lm(y ~ x)
    r2 <- summary(model)$r.squared

    r2_df_mofa_factors <- rbind(
      r2_df_mofa_factors,
      data.frame(Factor = f, Clinical_Variable = var, R2 = r2)
    )
  }
}

# Plot

ggplot(r2_df_mofa_factors, aes(
  x = as.numeric(gsub("Factor", "", Factor)),
  y = R2,
  color = Clinical_Variable,
  group = Clinical_Variable
)) +
  geom_line() +
  geom_point(size = 1.2) +
  theme_bw() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(gsub("Factor", "", r2_df_mofa_weights$Factor))), 2)) +
  labs(
    title = "Variance in MOFA Factors Explained by Clinical Variables",
    x = "MOFA Factor",
    y = expression(R^2 ~ " (from linear model)")
  )

```








# Gene set Analysis

```         
•   GSEA (Subramanian et al., 2005) > standard for testing global enrichment. (FGSEA fast preranked gene set enrichment analysis)
•   GSVA (Hänzelmann et al., 2013) > extends this by providing sample-wise enrichment scores, enabling downstream associations with phenotypes or latent factors.
```

## Gene sets

```{r, GSEA, include=TRUE, echo=TRUE}

# get Hallmark gene sets
#50 curated gene sets representing broad, well-defined biological processes (e.g., MYC targets, E2F targets, KRAS signaling, apoptosis)
pathways_hallmark <- msigdbr(species = "Homo sapiens", collection = "H") %>%
  split(x = .$gene_symbol, f = .$gs_name)

# get c2 gene sets
# Gene sets representing signatures of oncogene activation or inactivation (e.g., KRAS, MYC, E2F, PTEN loss).
pathways_c6 <- msigdbr(species = "Homo sapiens", collection = "C6") %>%
  split(x = .$gene_symbol, f = .$gs_name)

# get c2 gene sets
#Pathway databases and expert-curated gene sets, subdivided into:
##CGP (chemical/genetic perturbations) → genes responsive to drugs or perturbations.
##CP (canonical pathways) → pathways from KEGG, Reactome, BioCarta.
pathways_c2 <- msigdbr(species = "Homo sapiens", collection = "C2") %>%
  split(x = .$gene_symbol, f = .$gs_name)




```

## Run FGSEA

```{r}

## Run FGSEA for all factors

#gene set enrichment analysis (GSEA) to identify biological pathways and programs associated with the latent factors
# Extract weights for Factor 1 in RNASeq
# we extracted the feature weights for the top contributing genes in the rnaseq view, which represent the genes most associated with factor 1

all_weights <- get_weights(mofa_object.trained, 
                           views = "RNASeq", 
                           factors = "all", 
                           as.data.frame = TRUE)

# For each factor, run GSEA to understand biological meaning
factor_interpretation <- list()

for(factor_id in unique(all_weights$factor)) {
  # factor_id already has the form "Factor1", "Factor2", etc.
  
  # Get weights for this factor
  factor_weights <- all_weights[all_weights$factor == factor_id, ]
  
  # Create ranked list
  ranks <- factor_weights$value
  names(ranks) <- factor_weights$feature
  ranks <- sort(ranks, decreasing = TRUE)
  
  # Run GSEA on multiple gene set collections
  hallmark_res <- fgsea(pathways_hallmark, ranks, minSize = 15, maxSize = 500)
  c2_res      <- fgsea(pathways_c2, ranks, minSize = 15, maxSize = 500)
  c6_res      <- fgsea(pathways_c6, ranks, minSize = 15, maxSize = 500)
  
  # Store top pathways for interpretation
  factor_interpretation[[factor_id]] <- list(
    hallmark_top = hallmark_res[order(hallmark_res$pval), ][1:20, ],
    c2_top       = c2_res[order(c2_res$pval), ][1:20, ],
    c6_top       = c6_res[order(c6_res$pval), ][1:20, ]
  )
}


# Check any of the gene sets with factors
factor_interpretation$Factor3$c2_top

```

**Explanation of GSEA output (fgsea):**

-   **pathway** – Name of the gene set tested (e.g., Hallmark pathways).\

-   **pval** – Raw p-value from the enrichment test.\

-   **padj** – Adjusted p-value (FDR corrected).\

-   **ES (Enrichment Score)** – Degree to which a gene set is overrepresented at the top or bottom of the ranked list.\

-   **NES (Normalized Enrichment Score)** – Enrichment score normalized for gene set size, used to compare across gene sets.\

-   **size** – Number of genes in the pathway that overlap with the ranked list.\

-   **leadingEdge** – Subset of genes that contribute most to the enrichment signal.

-   Hallmark pathways from the GSEA results, ranked by normalized enrichment score (NES), with bars colored by whether the adjusted p-value (FDR) is significant (\< 0.05).

-   MYC targets (V1, V2), E2F targets, and KRAS signaling are strongly negatively enriched, suggesting suppression of cell-cycle–related and oncogenic signaling programs in the context of the factors identified by MOFA.

    -   MYC is a master regulator of proliferation, metabolism, and growth (Dang, Cell, 2012).

-   epithelial–mesenchymal transition (EMT), inflammatory response, interferon gamma response, and allograft rejection. This points to activation of immune and stromal programs.

## Factor Enrichment plot

```{r, include=TRUE}
# Plot enrichment for Factor1, top Hallmark pathway
enrichment_plot <- plot_factor_enrichment("Factor1", pathway_collection = "hallmark", top_n = 3, all_weights = all_weights)

# Display the plot
if(!is.null(enrichment_plot)) {
  print(enrichment_plot[[1]])
}
```

-   GSEA identified HALLMARK_MYC_TARGETS_V1 as one of the most significantly enriched pathways (FDR q \< 1e-28), indicating a central role of MYC-driven transcriptional programs in our dataset. Complementarily, GSVA revealed that MYC target activity varies across samples and is negatively correlated with MOFA Factor 1, suggesting that MYC activation is antagonistic to the biological processes captured by this factor.

## Run GSVA

```{r}
# Extract RNA-seq expression from MOFA
rna_se <- get_data(mofa_object.trained, view = "RNASeq")[[1]]  # first group if multiple
expr_mat <- as.matrix(rna_se$group1)  # genes x samples
# Hallmark
param_hallmark <- ssgseaParam(expr_mat, pathways_hallmark)
ssgsea_hallmark <- gsva(param_hallmark, verbose = FALSE)

# run GSVA on C2 and C6 for comprehensive coverage
param_c2 <- ssgseaParam(expr_mat, pathways_c2)
ssgsea_c2 <- gsva(param_c2, verbose = FALSE)

param_c6 <- ssgseaParam(expr_mat, pathways_c6) 
ssgsea_c6 <- gsva(param_c6, verbose = FALSE)

# Correlate ALL factors with ALL pathway collections
correlate_factors_pathways <- function(factor_mat, pathway_mat, pathway_name) {
  common_samples <- intersect(rownames(factor_mat), colnames(pathway_mat))
  factor_aligned <- factor_mat[common_samples, ]
  pathway_aligned <- t(pathway_mat[, common_samples])
  
  cor_matrix <- cor(factor_aligned, pathway_aligned, method = "spearman")
  return(cor_matrix)
}

# Get factor matrix (samples x factors)
fmat <- get_factors(mofa_object.trained, factors = "all", as.data.frame = FALSE)[[1]]

# Compute correlations
hallmark_cor <- correlate_factors_pathways(fmat, ssgsea_hallmark, "Hallmark")
c2_cor <- correlate_factors_pathways(fmat, ssgsea_c2, "C2")
c6_cor <- correlate_factors_pathways(fmat, ssgsea_c6, "C6")

# Find top correlated pathways for each factor
interpret_factors <- function(cor_matrix, pathways, n_top = 20) {
  factor_interpretations <- list()
  
  for(i in 1:nrow(cor_matrix)) {
    factor_cor <- cor_matrix[i, ]
    # Get top positive and negative correlations
    top_pos <- head(sort(factor_cor, decreasing = TRUE), n_top)
    top_neg <- head(sort(factor_cor, decreasing = FALSE), n_top)
    
    factor_interpretations[[rownames(cor_matrix)[i]]] <- list(
      positive_pathways = names(top_pos),
      positive_cor = top_pos,
      negative_pathways = names(top_neg), 
      negative_cor = top_neg
    )
  }
  return(factor_interpretations)
}

hallmark_interpret <- interpret_factors(hallmark_cor, pathways_hallmark)
c2_interpret <- interpret_factors(c2_cor, pathways_c2)
c6_interpret <- interpret_factors(c6_cor, pathways_c6)



```

# Latent Factor Visualization

## geom_col plot

```{r}
## geom_col plot

# Function to return individual plots
plot_factor_separate <- function(factor_id,
                                 gsea_collection = "hallmark",
                                 gsva_collection = "hallmark",
                                 max_pathways = 20) {
  
  plots <- list()
  
  # --- GSEA ---
  p_gsea <- plot_gsea(factor_id, gsea_collection, max_pathways)
  if (!is.null(p_gsea)) {
    p_gsea <- p_gsea +
      theme_minimal() +
      theme(
        axis.text.y = element_text(size = 9, hjust = 1),
        axis.title = element_blank(),
        plot.margin = margin(5, 10, 5, 50)
      ) +
      ggtitle(paste("Factor:", factor_id, "- GSEA"))
  } else {
    p_gsea <- ggplot() + theme_void() + ggtitle(paste(factor_id, "GSEA missing"))
  }
  plots[["GSEA"]] <- p_gsea
  
  # --- GSVA ---
  p_gsva <- plot_gsva(factor_id, gsva_collection, max_pathways)
  if (!is.null(p_gsva)) {
    p_gsva <- p_gsva +
      theme_minimal() +
      theme(
        axis.text.y = element_text(size = 4, hjust = 1),
        axis.title = element_blank(),
        plot.margin = margin(5, 10, 5, 50)
      ) +
      ggtitle(paste("Factor:", factor_id, "- GSVA"))
  } else {
    p_gsva <- ggplot() + theme_void() + ggtitle(paste(factor_id, "GSVA missing"))
  }
  plots[["GSVA"]] <- p_gsva
  
  return(plots)
}

# Factors to plot
top_factors <- c("Factor1", "Factor2", "Factor3")

# Generate and print each plot separately
for (f in top_factors) {
  plots <- plot_factor_separate(f, gsea_collection = "c2", gsva_collection = "c2", max_pathways = 8)
  
  print(plots[["GSEA"]])
  print(plots[["GSVA"]])
}
```

## Heatmap plot

```{r}
library(RColorBrewer)
# GSEA heatmap for Hallmark pathways
plot_gsea_heatmap("hallmark", top_n_pathways = 40)

# GSVA heatmap for Hallmark pathways
plot_gsva_heatmap("hallmark", top_n_pathways = 30)

# You can switch to "c2" or "c6"
plot_gsea_heatmap("c2", top_n_pathways = 20)
plot_gsva_heatmap("c2", top_n_pathways = 20)



```

# Table

```{r}
# ---- Integrated interpret_factor function ----
interpret_factor <- function(factor_id,
                             top_n_pathways = 10,
                             top_n_genes = 10,
                             gsva_collections = c("hallmark","c2","c6"),
                             gsea_collections = c("hallmark","c2","c6")) {
  
  # --- Top genes ---
  all_weights <- get_weights(mofa_object.trained, views="RNASeq", factors=factor_id, as.data.frame=TRUE)
  top_genes <- head(all_weights[order(-abs(all_weights$value)), ], top_n_genes)
  
  # --- FGSEA ---
  gsea_summary <- list()
  ranks <- setNames(all_weights$value, all_weights$feature)
  ranks <- sort(ranks, decreasing = TRUE)
  
  if("hallmark" %in% gsea_collections) {
    res <- fgsea(pathways_hallmark, ranks, minSize=15, maxSize=500)
    gsea_summary$hallmark <- if(nrow(res) > 0) res[order(res$pval), ][1:top_n_pathways, ] else NULL
  }
  if("c2" %in% gsea_collections) {
    res <- fgsea(pathways_c2, ranks, minSize=15, maxSize=500)
    gsea_summary$c2 <- if(nrow(res) > 0) res[order(res$pval), ][1:top_n_pathways, ] else NULL
  }
  if("c6" %in% gsea_collections) {
    res <- fgsea(pathways_c6, ranks, minSize=15, maxSize=500)
    gsea_summary$c6 <- if(nrow(res) > 0) res[order(res$pval), ][1:top_n_pathways, ] else NULL
  }
  
  # --- GSVA correlations ---
  gsva_summary <- list()
  if("hallmark" %in% gsva_collections) gsva_summary$hallmark <- hallmark_interpret[[factor_id]]
  if("c2" %in% gsva_collections)       gsva_summary$c2 <- c2_interpret[[factor_id]]
  if("c6" %in% gsva_collections)       gsva_summary$c6 <- c6_interpret[[factor_id]]
  
  list(
    top_genes = top_genes,
    gsea_summary = gsea_summary,
    gsva_summary = gsva_summary
  )
}

create_summary_table <- function(factor_ids = paste0("Factor", 1:10),
                                 top_n_pathways = 5,
                                 top_n_genes = 10,
                                 interpretations = NULL) {
  
  # Pre-define all possible columns to ensure consistency
  all_gsea_cols <- c("Top_HALLMARK_GSEA_Pathways", "Top_C2_GSEA_Pathways", "Top_C6_GSEA_Pathways")
  all_gsva_cols <- c("Top_HALLMARK_GSVA_Pathways", "Top_C2_GSVA_Pathways", "Top_C6_GSVA_Pathways")
  
  reports <- lapply(factor_ids, function(fid) {
    
    # ---- Get interpretation outputs ----
    out <- interpret_factor(fid,
                            top_n_pathways = top_n_pathways,
                            top_n_genes = top_n_genes)
    
    # ---- Top genes ----
    top_genes_text <- NA
    if(!is.null(out$top_genes) && nrow(out$top_genes) > 0) {
      top_genes_vec <- as.character(out$top_genes$feature)
      if(is.list(top_genes_vec)) top_genes_vec <- unlist(top_genes_vec)
      top_genes_text <- paste(head(top_genes_vec, top_n_genes), collapse = ", ")
    }
    
    # ---- GSEA columns ----
    gsea_cols <- setNames(rep(NA, length(all_gsea_cols)), all_gsea_cols)
    
    for(col in names(out$gsea_summary)) {
      col_name <- paste0("Top_", toupper(col), "_GSEA_Pathways")
      res <- out$gsea_summary[[col]]
      if(!is.null(res) && nrow(res) > 0) {
        res <- res[order(res$pval), , drop = FALSE]
        res <- head(res, min(top_n_pathways, nrow(res)))
        gsea_cols[col_name] <- paste(res$pathway, "(p=", signif(res$pval, 2), ")", collapse = "; ")
      }
    }
    
    # ---- GSVA columns ----
    gsva_cols <- setNames(rep(NA, length(all_gsva_cols)), all_gsva_cols)
    
    for(col in names(out$gsva_summary)) {
      col_name <- paste0("Top_", toupper(col), "_GSVA_Pathways")
      cor_vec <- out$gsva_summary[[col]]
      if(!is.null(cor_vec) && length(cor_vec) > 0) {
        # Ensure we have a named numeric vector
        if(is.data.frame(cor_vec)) {
          if(ncol(cor_vec) == 1) {
            cor_vec <- setNames(cor_vec[,1], rownames(cor_vec))
          } else {
            cor_vec <- setNames(cor_vec[,1], rownames(cor_vec)) # Take first column
          }
        }
        if(is.list(cor_vec)) cor_vec <- unlist(cor_vec)
        
        # Get top correlations
        if(length(cor_vec) > 0 && !is.null(names(cor_vec))) {
  cor_vec <- suppressWarnings(as.numeric(cor_vec))
  names(cor_vec) <- names(out$gsva_summary[[col]])  # restore names if lost
  cor_vec <- cor_vec[!is.na(cor_vec)]
  if(length(cor_vec) > 0) {
    top_cor <- head(sort(cor_vec, decreasing = TRUE), top_n_pathways)
    gsva_cols[col_name] <- paste(names(top_cor), "[cor=", signif(top_cor, 2), "]", collapse = "; ")
  }
}
      }
    }
    
    # ---- Combine all into one row ----
    result_row <- data.frame(
      Factor = fid,
      Top_Genes = top_genes_text,
      Interpretation = if(!is.null(interpretations) && fid %in% names(interpretations)) interpretations[[fid]] else NA,
      stringsAsFactors = FALSE
    )
    
    # Add GSEA and GSVA columns in consistent order
    for(col_name in all_gsea_cols) {
      result_row[[col_name]] <- gsea_cols[col_name]
    }
    for(col_name in all_gsva_cols) {
      result_row[[col_name]] <- gsva_cols[col_name]
    }
    
    return(result_row)
  })
  
  # Combine all rows
  final_table <- do.call(rbind, reports)
  return(final_table)
}


# Add the interpretation based on the table
interpretations <- list(
  Factor1 = "Oncogenic proliferation program characterized by MYC/E2F-driven cell cycle activity, KRAS/TGF-β signaling, and smooth muscle/stromal gene expression (MYH11, DES, CNN1)",
  
  Factor2 = "oxidative stress response with immune activation features (allograft rejection, interferon signaling) and angiogenesis regulation",
  
  Factor3 = "Metabolic reprogramming program centered on oxidative phosphorylation and myogenesis, with epithelial-mesenchymal transition and coagulation pathway activation",
  
  Factor4 = "Mitotic and metabolic axis featuring spindle assembly, oxidative phosphorylation, and adipogenesis, with strong autophagy and amino acid metabolism components",
  
  Factor5 = "Advanced cancer progression signature with strong EMT, fatty acid metabolism, and matrisome remodeling, indicative of invasive tumor phenotype",
  
  Factor6 = "Immune-excluded tumor microenvironment characterized by interferon response, glycolytic metabolism, mTOR signaling, and hypoxia adaptation",
  
  Factor7 = "Cell cycle checkpoint and mTOR signaling program with weak immune associations, potentially representing proliferative but immunologically quiet tumors",
  
  Factor8 = "Inflammatory cancer phenotype with EMT, TNFα/NF-κB signaling, KRAS activation, and extracellular matrix organization",
  
  Factor9 = "Antiviral immune response signature featuring strong interferon signaling, cytokine activity (CXCL9, GZMA), and regulated cell death pathways",
  
  Factor10 = "Differentiation and secretory program with EMT, androgen response, protein secretion, and weak WNT/β-catenin signaling"
)
# 1. Create the table data first
all_factors_table <- create_summary_table(
  factor_ids = paste0("Factor", 1:10),
  top_n_pathways = 5,
  top_n_genes = 10,
  interpretations = interpretations
)

```

# Interpretation Report

```{r}
rmd_html <- "MOFA_factor_summary.Rmd"

writeLines(c(
"---",
"title: '<center>MOFA Factor Analysis: Biological Pathway Associations</center>'",
"output:",
"  html_document:",
"    toc: true",
"    toc_float: true",
"    toc_depth: 3",
"    number_sections: true",
"    theme: flatly",
"    css: styles.css",
"    df_print: paged",
"---",
"",
"```{r setup, include=FALSE}",
"knitr::opts_chunk$set(",
"  echo = FALSE, warning = FALSE, message = FALSE,",
"  fig.align = 'center', fig.width = 7, fig.height = 5,",
"  out.width = '100%', fig.show = 'asis'",
")",
"library(kableExtra); library(dplyr); library(DT); library(patchwork); library(ggplot2)",
"```",
"",
"<style>",
"@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Merriweather:wght@400;700&display=swap');",
"body {font-family: 'Roboto', sans-serif; line-height: 1.7; color: #2c3e50; background-color: #fafafa; max-width: 1100px; margin: auto; padding: 20px;}",
"h1, h2, h3 {font-family: 'Merriweather', serif; color: #1a5276; margin-top: 2em; padding-bottom: 0.3em; border-bottom: 2px solid #5dade2;}",
"table {border-collapse: collapse; margin: 1em 0;}",
"th {background-color: #1a5276; color: #f8f9fa; font-weight: 600; padding: 8px; text-align: left;}",
"td {padding: 8px; border-bottom: 1px solid #ddd;}",
".table-caption {font-weight: 600; font-size: 1.1em; color: #34495e; margin-bottom: 8px;}",
"code, pre {font-family: 'Fira Code', monospace; background-color: #f4f6f6; padding: 2px 6px; border-radius: 4px;}",
"</style>",
"",
"# Introduction",
"Using processed WSIs from ProviGigaPath, we extracted image embeddings representing tissue features. These embeddings were aligned with TCGA multi-omics data, including RNA-seq, enabling cross-modal analysis.",
"",
"MOFA (Multi-Omics Factor Analysis) was used to identify latent factors capturing shared variation across modalities. Embedding weights were correlated with factor loadings to identify visual-molecular associations.",
"",
"Biological interpretation was achieved via FGSEA and GSVA applied to RNA-seq factor loadings, revealing enriched pathways per factor. This pipeline links histology patterns to molecular mechanisms in an interpretable manner.",
"",
"# Data Sources and Pipeline",
"- **MOFA Model:** Prov-GigaPath WSI embeddings + RNAseq",
"- **Pathway Databases:** MSigDB Hallmark, C2, C6",
"- **Methods:** FGSEA (preranked), GSVA (sample-level)",
"- **Pipeline:**",
"  1. Extract factor weights",
"  2. Perform FGSEA on loadings",
"  3. Compute GSVA pathway activities",
"  4. Correlate factors with pathway activities",
"",
"# Latent Factor Visualization",
"```{r factor-plots, fig.width=12, fig.height=8}",
"print(plot_variance_explained(mofa_object.trained, plot_total = TRUE))",
"```",
"",
"# PCA on Embeddings",
"```{r pca-analysis, fig.width=10, fig.height=8}",
"pca_res <- prcomp(embedding_matched, scale. = TRUE)",
"pca_scores <- as.data.frame(pca_res$x)",
"",
"# Correlate PCA components with MOFA factors",
"pca_factor_cor <- cor(pca_scores, factor_scores_matched[, -1], use = 'pairwise.complete.obs')",
"",
"# PCA scatter plot",
"ggplot(pca_scores, aes(PC1, PC2)) +",
"  geom_point(color = 'gray40', size = 2) +",
"  theme_minimal(base_size = 14) +",
"  labs(",
"    title = 'PCA of Image Embeddings',",
"    x = paste0('PC1 (', round(summary(pca_res)$importance[2,1]*100,1), '% var)'),",
"    y = paste0('PC2 (', round(summary(pca_res)$importance[2,2]*100,1), '% var)')",
"  )",
"```",
"",
"# Embedding–Factor Tables",
"## Table 1: Factor × Embedding Dimension Correlations",
"```{r embedding-factor-correlation, results='asis'}",
"if (exists('embedding_corr_table')) {",
"  top_corr_table <- embedding_corr_table %>%",
"    group_by(Factor) %>%",
"    slice_max(order_by = Abs_Corr, n = 20) %>%",
"    ungroup()",
"",
"  kable(top_corr_table, format = 'html', escape = FALSE,",
"        caption = '<strong>Table 1: Top Correlated Embeddings per Factor</strong>') %>%",
"    kable_styling(bootstrap_options = c('striped', 'hover', 'condensed'), full_width = TRUE, font_size = 12) %>%",
"    scroll_box(width = '100%', height = '500px')",
"}",
"```",
"",
"## Table 2: Top Weighted Embeddings from MOFA",
"```{r embedding-weight-table, results='asis'}",
"if (exists('embedding_weight_table')) {",
"  kable(embedding_weight_table, format = 'html', escape = FALSE,",
"        caption = '<strong>Table 2: Top Weighted Embeddings per Factor (from MOFA Model)</strong>') %>%",
"    kable_styling(bootstrap_options = c('striped', 'hover','condensed'), full_width = TRUE, font_size = 12) %>%",
"    scroll_box(width = '100%', height = '500px')",
"}",
"```",
"",
"# GSEA / GSVA Factor Interpretation Table",
"```{r factor-interpretation-table, results='asis'}",
"if (exists('all_factors_table')) {",
"  kable(all_factors_table, format = 'html', escape = FALSE,",
"        caption = '<strong>Table 3: Factor-wise GSEA/GSVA and Top Gene Interpretations</strong>') %>%",
"    kable_styling(bootstrap_options = c('striped','hover','condensed'), full_width = TRUE, font_size = 12) %>%",
"    scroll_box(width = '100%', height = '700px')",
"}",
"```",
"",
"## Embedding–Factor Projection Plots (Factors 1, 3, 5)",
"```{r embedding-projections, fig.width=7, fig.height=5}",
"selected_factors <- c('Factor1','Factor3','Factor5')",
"Xs <- scale(as.matrix(embedding_matched))",
"Ys <- scale(as.matrix(factor_scores_matched[, -1]))",
"W <- as.matrix(embedding_weights)",
"for (j in selected_factors) {",
"  w_j <- W[, j]",
"  proj_wj <- Xs %*% w_j",
"  cor_val <- cor(proj_wj, Ys[, j])",
"  plot(Ys[, j], proj_wj, pch = 16, col = 'gray40',",
"       xlab = paste('MOFA factor', j), ylab = 'Projection on embedding weights',",
"       main = paste(j, '- correlation =', round(cor_val, 3)))",
"  abline(lm(proj_wj ~ Ys[, j]), col = 'red', lwd = 2)",
"}",
"```"
), con = rmd_html)
rmarkdown::render(rmd_html, output_file = "MOFA_factor_summary_T2.html")

```

```{r}
# =========================================================
# Fast MOFA Factor HTML Report with Precomputed Tables
# =========================================================

rmd_html <- "MOFA_factor_summary_fast.Rmd"

writeLines(c(
  "---",
  "title: '<center>MOFA Factor Analysis: Biological Pathway Associations</center>'",
  "output:",
  "  html_document:",
  "    toc: true",
  "    toc_float: true",
  "    toc_depth: 3",
  "    number_sections: true",
  "    theme: journal",
  "    css: styles.css",
  "    df_print: paged",
  "---",
  "",
  "```{r setup, include=FALSE}",
  "knitr::opts_chunk$set(",
  "  echo = FALSE, warning = FALSE, message = FALSE,",
  "  fig.align = 'center',",
  "  fig.width = 7, fig.height = 5,",
  "  out.width = '100%',",
  "  fig.show = 'asis'",
  ")",
  "library(kableExtra)",
  "library(dplyr)",
  "library(DT)",
  "library(patchwork)",
  "library(ggplot2)",
  "```",
  "",
  "<style>",
  "@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Merriweather:wght@400;700&display=swap');",
  "body { font-family: 'Roboto', sans-serif; line-height: 1.7; color: #2c3e50; background-color: #fafafa; max-width: 1100px; margin: auto; padding: 20px; }",
  "h1, h2, h3 { font-family: 'Merriweather', serif; color: #1a5276; margin-top: 2em; padding-bottom: 0.3em; border-bottom: 2px solid #5dade2; }",
  "table { border-collapse: collapse; margin: 1em 0; }",
  "th { background-color: #5dade2; color: #fff; padding: 8px; text-align: left; }",
  "td { padding: 8px; border-bottom: 1px solid #ddd; }",
  ".table-caption { font-weight: 600; font-size: 1.1em; color: #34495e; margin-bottom: 8px; }",
  "code, pre { font-family: 'Fira Code', monospace; background-color: #f4f6f6; padding: 2px 6px; border-radius: 4px; }",
  "</style>",
  "",
  "# Introduction",
  "MOFA identifies latent factors that capture coordinated variation across multi-omics datasets. This analysis interprets these factors through their associations with curated biological pathways.",
  "",
  "# Data Sources and Pipeline",
  "- **Precomputed Tables**: all_factors_table.rds, enhanced_summary.rds",
  "- **Analysis Methods**: GSEA (preranked), GSVA (sample-level)",
  "",
  "# Latent Factor Tables",
  "",
  "## Summary of Factor Interpretations",
  "```{r summary-table, results='asis'}",
  "all_factors_table <- readRDS('all_factors_table.rds')",
  "if (exists('all_factors_table')) {",
  "  kable(all_factors_table, format = 'html', escape = FALSE,",
  "        caption = '<strong>Table 1: MOFA Factor Biological Interpretations</strong>') %>%",
  "    kable_styling(bootstrap_options = c('striped','hover','condensed'), full_width = TRUE, font_size = 12, position = 'center') %>%",
  "    column_spec(1, bold = TRUE, width = '80px') %>%",
  "    column_spec(2, width = '100px') %>%",
  "    column_spec(3, width = '200px') %>%",
  "    column_spec(4:ncol(all_factors_table), width = '250px') %>%",
  "    scroll_box(width = '100%', height = '500px')",
  "}",
  "```",
  "",
  "## Embedding Correlation Summary",
  "```{r embedding-correlation-table, results='asis'}",
  "enhanced_summary <- readRDS('enhanced_summary.rds')",
  "if (exists('enhanced_summary')) {",
  "  comprehensive_table <- enhanced_summary %>%",
  "    select(Factor = factor, `Best Embedding` = best_embedding, Correlation = correlation,",
  "           `Top Positive Pathway` = top_positive_pathway_clean,",
  "           `Top Negative Pathway` = top_negative_pathway_clean,",
  "           `Top RNA Genes` = top_rna_genes) %>%",
  "    arrange(desc(abs(Correlation)))",
  "",
  "  kable(comprehensive_table, format = 'html', escape = FALSE,",
  "        caption = '<strong>Table 2: Correlations Between MOFA Factors and Image Embeddings</strong>') %>%",
  "    kable_styling(bootstrap_options = c('striped','hover','condensed'), full_width = TRUE, font_size = 12, position = 'center') %>%",
  "    column_spec(1, bold = TRUE, width = '100px') %>%",
  "    column_spec(2, width = '150px') %>%",
  "    column_spec(3, width = '100px') %>%",
  "    column_spec(4:6, width = '250px') %>%",
  "    scroll_box(width = '100%', height = '500px')",
  "}",
  "```"
), con = rmd_html)

# Render HTML
rmarkdown::render(rmd_html, output_file = "MOFA_factor_summarys.html")
```

-   Factor 1 represents a proliferative, MYC-driven program enriched for E2F targets, KRAS signaling, and EMT pathways, reflecting high cell-cycle activity and transcriptional programs associated with tumor growth. In the context of colorectal cancer, it likely marks aggressive, mesenchymal-like tumors with enhanced proliferation, invasion, and metastatic potential.

#### Surv analysis

-   The clinical features have 5 dimensions: T stage, N stage, M stage, total stage, and whether or not to receive chemotherapy after surgery \[1\]

\[1\] Cai, C., Zhou, Y., Jiao, Y. et al. Prognostic Analysis Combining Histopathological Features and Clinical Information to Predict Colorectal Cancer Survival from Whole-Slide Images. Dig Dis Sci 69, 2985–2995 (2024). https://doi-org.ccny-proxy1.libr.ccny.cuny.edu/10.1007/s10620-024-08501-x

```{r}
# ==============================
# Survival Analysis: MOFA + GSVA + Clinical
# ==============================
# -----------------------------
# 1. Load metadata and MOFA factors
# -----------------------------
meta <- samples_metadata(mofa_object.trained)

# Compute survival time
meta$time <- ifelse(meta$vital_status.x == 1, 
                    meta$days_to_death.x,
                    pmax(meta$patient.days_to_last_followup,
                         meta$patient.days_to_last_known_alive,
                         na.rm = TRUE))
meta$time <- pmax(meta$time, 0)  # ensure non-negative
meta$event <- meta$vital_status.x  # 1 = death, 0 = censored

cat("Event counts:\n")
print(table(meta$event, useNA="ifany"))

# -----------------------------
# 2. Kaplan-Meier by histological type
# -----------------------------
km_fit_hist <- survfit(Surv(time, event) ~ patient.stage_event.tnm_categories.pathologic_categories.pathologic_t,
                       data = meta)
ggsurvplot(
  km_fit_hist, data = meta,
  risk.table = TRUE,
  pval = TRUE,
  palette = "Dark2",
  title = "Kaplan-Meier Survival by Histological Type",
  xlab = "Days",
  ylab = "Survival Probability"
)

# -----------------------------
# 3. Extract and align MOFA factors
# -----------------------------
fmat <- get_factors(mofa_object.trained, factors = "all", as.data.frame = FALSE)[[1]]
common_samples <- intersect(rownames(meta), rownames(fmat))
meta2 <- meta[common_samples, , drop = FALSE]
fmat2 <- fmat[common_samples, , drop = FALSE]

# Attach all factors as numeric
for(i in 1:5){
  meta2[[paste0("factor", i)]] <- as.numeric(fmat2[, i])
}

# -----------------------------
# 4. Attach top GSVA pathways per factor
# -----------------------------
# Top 3 pathways per factor from correlation matrix
top_per_factor <- apply(abs(cor_matrix), 1, function(x) names(sort(x, decreasing = TRUE))[1:3])
cand_pathways <- unique(as.vector(top_per_factor))

# Extract these pathways from pathway_df and align
cand_pathways_df <- pathway_df[, cand_pathways, drop=FALSE]
common_samples <- intersect(rownames(meta2), rownames(cand_pathways_df))
meta2 <- meta2[common_samples, ]
cand_pathways_df <- cand_pathways_df[common_samples, ]
meta2 <- cbind(meta2, cand_pathways_df)




```

#### Univariable Cox regression

```{r}
# -----------------------------
# 5. Define candidate variables
# -----------------------------
clinical_vars <- c("age", "sex", "pathology_T_stage", "pathology_N_stage", 
                   "pathology_M_stage", "patient.stage_event.tnm_categories.pathologic_categories.pathologic_t")
factor_vars <- paste0("factor", 1:5)
cand_vars <- c(clinical_vars, factor_vars, cand_pathways)
cand_vars <- cand_vars[cand_vars %in% colnames(meta2)]

# -----------------------------
# 6. Univariable Cox regression
# -----------------------------
univ_results <- lapply(cand_vars, function(v){
  form <- as.formula(paste0("Surv(time, event) ~ `", v, "`"))
  m <- tryCatch(coxph(form, data = meta2), error = function(e) NULL)
  if(is.null(m)) return(data.frame(var=v, HR=NA, p=NA))
  s <- summary(m)
  data.frame(var=v, HR=exp(s$coef[1,"coef"]), p=s$coef[1,"Pr(>|z|)"], stringsAsFactors=FALSE)
})
univ_results <- do.call(rbind, univ_results)
univ_results <- univ_results %>% arrange(p)

# Inspect univariable results
univ_results




```

#### Multivariable Cox regression

```{r}
# -----------------------------
# 7. Multivariable Cox regression
# -----------------------------
# Select top factors, pathways, and clinical covariates based on univariable p < 0.05
top_factors <- c("factor1","factor2","factor3","factor4")  # example
top_pathways <- c("HALLMARK_MITOTIC_SPINDLE",
                  "HALLMARK_PI3K_AKT_MTOR_SIGNALING",
                  "HALLMARK_SPERMATOGENESIS")  # example
clin_vars <- c("pathology_M_stage")  # example
mv_vars <- c(top_factors, top_pathways, clin_vars)
mv_vars <- mv_vars[mv_vars %in% colnames(meta2)]

# Standardize continuous variables for Cox
num_vars <- mv_vars[sapply(meta2_std[, mv_vars], is.numeric)]

for(v in num_vars){
  meta2_std[[v]] <- as.numeric(scale(meta2_std[[v]]))
}

# Fit multivariable Cox model
cox_formula <- as.formula(paste0("Surv(time, event) ~ ", paste(mv_vars, collapse = " + ")))
cox_mv <- coxph(cox_formula, data = meta2_std)
summary(cox_mv)
```
